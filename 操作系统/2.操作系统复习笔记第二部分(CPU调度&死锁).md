# Chap6 CPU调度-1

## 6.1 CPU调度的背景

### 6.1.1 需要调度的原因

> 多个进程竞争同时有限的CPU计算资源，所以需要决定哪个进程优先执行



### 6.1.2 何时进行调度(调度发生在进程状态转换的哪个阶段)

[<img src="https://s1.ax1x.com/2020/08/15/dkjKQf.md.jpg" alt="dkjKQf.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dkjKQf)



###### 非抢占的

> 1. 进程从running切换到waiting状态时
> 2. 进程终止时



###### 抢占的

> 1. 进程从waiting切换到ready时
> 2. 进程从running切换到ready时



## 6.2 调度的方法与评价准则

### 6.2.1 如何进行调度

> Dispatcher通过以下步骤将CPU的控制权交给经过短期调度选出的进程
>
> 1. 切换上下文(切换到将要执行的进程对应的上下文)
> 2. 切换为用户模式
> 3. 跳转到用户程序的正确位置来重启程序



[<img src="https://s1.ax1x.com/2020/08/15/dkvChn.md.jpg" alt="dkvChn.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dkvChn)



### 6.2.2 评价准则

#### 6.2.2.1 准则

1. CPU Utilization CPU利用率 

   > 顾名思义，代表CPU的使用效率

2. Throughput 吞吐量

   > 固定时间段内CPU完成计算的进程个数

3. TurnaroundTime 周转时间

   > 对于单个进程，从到达ready队列到执行完毕的时间
   >
   > 等待时间+实际执行花费时间

4. Waiting Time 等待时间

   > 进程执行前在队列中等待的时间

5. Response Time 响应时间

   > 从请求提交到第一个响应产生的时间
   >
   > 对于批处理系统(Batch System):响应时间==周转时间，因为响应就说明计算完成了
   >
   > 对于分时系统(Time-Sharing System):响应时间！=周转时间，因为响应有可能代表计算完成，也有可能仅代表第一个时间片结束

   

#### :fire:6.2.2.2 目标

1. CPU利用率最大化
2. 吞吐量最大化
3. 周转时间最短
4. 等待时间最短
5. 响应时间最短





## :fire:6.3 批处理系统的调度算法

#### 6.3.0 批处理系统的介绍

> 专门用于调度的算法被称为调度算法。
>
> 在批处理系统中，常用的调度算法有以下几个：
>
> 1. FCFS(First Come First Serve)
> 2. SJF(Shortest Job First)
> 3. SRTF(Shortest Remain Time First)
> 4. TL S(Three-Level Scheduling)



#### :zap: 6.3.1 FCFS(First Come First Serve)

##### 6.3.1.1 原理

> “先到先服务”，按到达ready序列的顺序计算，是最简单的调度算法

==非抢占==



##### 6.3.1.2 示意图

###### 原理图

[![depJLn.md.jpg](https://s1.ax1x.com/2020/08/17/depJLn.md.jpg)](https://imgchr.com/i/depJLn)

###### 甘特图举例(之后的调度算法略去此图)

[![dmsEHf.md.jpg](https://s1.ax1x.com/2020/08/17/dmsEHf.md.jpg)](https://imgchr.com/i/dmsEHf)



##### 6.3.1.3 优缺点

###### 优点

1.实现简单



###### 缺点

1.不灵活

2.如果执行时间长的进程先进入队列，则有可能导致护航现象(convey effect)出现

Tips:护航现象，指很多进程等待一个大的进程执行完毕释放资源的现象



#### :zap:6.3.2 SJF(Shortest-Job-First)

##### 6.3.2.1 原理

> 最短执行时间作业优先。按照队列中作业的执行时间排序，越短越靠前

==非抢占==

Tips:注意，如果一个执行时间较长的进程已经在执行，则SJF不会抢占计算资源，

##### 6.3.2.2 示意图

[![depXY8.md.jpg](https://s1.ax1x.com/2020/08/17/depXY8.md.jpg)](https://imgchr.com/i/depXY8)

##### 6.3.2.3 优缺点

###### 优点

> 理论上，SJF无疑是最佳的，能够给出最短的平均等待时间



###### 缺点

> 最关键的缺点是，难以预测进程的执行时间是多少：
>
> 1. 对于长期调度：可以通过用户声明的进程时间限制来调度
> 2. 对于短期调度，无法获取



##### 6.3.2.4 预测执行时间

> 在执行时间不知道的情况下，想要使用SJF调度算法，则需要进行预测
>
> 
>
> 预测公式：$\tau_{n+1} = \alpha t_n + (1-\alpha)\tau_n$
>
> $\tau_{n+1} $:对第n+1次CPU执行时间的预测值
>
> t~n~:第n次CPU执行时间的确切值
>
> $\alpha$:[0,1]之间的系数
>
> 当 $\alpha$=0时，上一次CPU执行时间与此次预测毫无关系
>
> 当$\alpha$=1时，直接以上一次的执行时间作为预测值



#### :zap:6.3.3 SRTF(Shortest-Remain-Time-First)

##### 6.3.3.1 原理

> SRTF实际上就是一个抢占版本的SJF



- 永远选中剩余执行时间最短的进程
- 如果一个新来的进程的执行时间比正在执行的进程执行时间还要段，则将抢占CPU资源



==抢占==

##### 6.3.3.2 示意图

和SJF一样，略



#### 6.3.4 Three-Level

##### 6.3.4.1 三级调度的概念

> 在有的操作系统中仅采用一级凋度，而有的操作系统则将凋度分为不同的层次，一个用户作业从进入系统成为后备作业开始，直到运行结退出系统为止，一般最多经历三级调度，即处理器调度可以分为3个层次，分别是高、中、低级调度。



##### 6.3.4.2 示意图

[<img src="https://s1.ax1x.com/2020/08/17/dmsJET.md.jpg" alt="dmsJET.md.jpg" style="zoom:67%;" />](https://imgchr.com/i/dmsJET)





# Chap7 CPU调度-2

## 7.1 交互式系统的调度算法

### 7.1.0 交互式系统的介绍

###### 简介

> 人机交互是指人与计算机之间使用某种对话语言，以一定的交互方式，为完成确定任务的人与机器之间的信息交换过程。基于此，为达到人机交互目的而为机器所编写的操作系统称为交互式操作系统。



###### 系统目标

> 响应时间：能够迅速响应用户的请求
>
> 均衡性：能够满足用户的预期



###### 常见的交互式系统调度算法

> 1. 优先级调度
> 2. 时间片轮转法
> 3. 多级队列调度
> 4. 多级反馈队列调度



### 7.1.1 优先级调度(Priority)

#### 7.1.1.1 原理

> 每个进程都持有一个优先级，优先级高的会被放置在就绪队列的前面



- 优先级一般是一个固定范围的数字，比如1~10，常用的做法是数字越小，代表优先级越高
- SJF就是一个特殊的例子，相当于队列中所有进程的优先级相等
- 优先级调度可以分为抢占的和非抢占的，可以参考SRTF调度算法



#### 7.1.1.2 示意图

P2-->P4的执行遵照优先级的顺序

![dn4uEd.jpg](https://s1.ax1x.com/2020/08/18/dn4uEd.jpg)

#### 7.1.1.3 优缺点

###### 优点

1. 实现起来比SRTF更加简单
2. 支持选择抢占/非抢占的方式实现



###### 缺点

低优先级的进程可能会陷入饥饿状态/无限等待状态，即永远在等待更高优先级的进程执行



### :fire:7.1.2 时间片轮转法调度(Round-Robin)

#### 7.1.2.1 原理

> 为了防止优先级调度导致的饥饿问题，给每一个进程一个最大的执行时间。当执行时间结束，而此进程还没执行完的话，则它会被挂起，让出CPU资源供下一个进程使用



#### 7.1.2.2 示意图

[<img src="https://s1.ax1x.com/2020/08/18/dnTZRI.md.jpg" alt="dnTZRI.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dnTZRI)



#### 7.1.2.3 特点

假设时间片的大小为q

Q很大：时间片轮转法趋近于FCFS，因为大部分进程都能一次执行完

Q很小：进程切换时的上下文切换耗费时间显著提升(注意，q至少应该大于上下文切换的时间)





### 7.1.3 多级队列调度

#### 7.1.3.1 原理

> 如果进程可以方便地进行分组的话，那么可以将不同进程放入不同优先级的队列中，而每个队列又可以采取不一样的调度算法，从而灵活地进行调度



#### 7.1.3.2 示意图

[![dnT2y6.jpg](https://s1.ax1x.com/2020/08/18/dnT2y6.jpg)](https://imgchr.com/i/dnT2y6)



#### 7.1.3.3 优缺点

###### 优点

能够根据不同的优先级选择不同的调度方式



###### 缺点

不支持进程在不同的队列之间移动，仍然缺少一些灵活性





### 7.1.4 多级反馈队列调度

#### 7.1.4.1 原理

> 多级反馈队列就是支持进程在不同队列间移动的多级队列调度算法
>
> 1. 如果一个进程使用了过多的CPU时间，则它将会被移动到低优先级的队列中
> 2. 如果一个进程长时间处于低优先级的队列中，则它会被提到高优先级的队列中



#### 7.1.4.2 示意图

[![dnHZKP.md.jpg](https://s1.ax1x.com/2020/08/18/dnHZKP.md.jpg)](https://imgchr.com/i/dnHZKP)



#### 7.1.4.3 实现

> 多级反馈队列的实现被如下的方法/参数定义
>
> 1. 队列的个数
> 2. 每个队列中使用的调度算法
> 3. 提高进程优先级的方法
> 4. 降低进程优先级的方法
> 5. 决定把新来的进程放入哪个队列的方法



## 7.2 实时系统的调度算法

### 7.2.1 实时系统的介绍

> 一个实时系统是指计算的正确性不仅取决于程序的逻辑正确性，也取决于结果产生的时间，如果系统的时间约束条件得不到满足，将会发生系统出错。



###### 软实时系统

> 关键的实时任务拥有最高的优先级，但软实时系统不保证任务执行的时间



###### 硬实时系统

> 任务必须在deadline之前结束执行



###### 事件延迟(Event Latency)

> 事件从到达到被响应中间间隔的时间
>
> 两种类型的延迟：
>
> 1. 中断延迟(Interrupt Latency)
>
>    系统产生中断导致的延迟
>
> 2. 分配延迟(Dispatch Latency)
>
>    系统切换执行的进程导致的延迟



### 7.2.2 基于优先级的调度

> 对于实时操作系统来说，它必须支持==抢占的==，==基于优先级的==调度算法(但是只支持到软实时程度，硬实时需要硬件来保障)



### 7.2.3 RMS(单调速率调度)

> 一个进程的优先级由它来到系统的次数来决定
>
> - 越频繁来到系统的进程：优先级低
> - 越不频繁来到系统的进程：优先级高



### 7.2.4 EDF(Earliest Deadline First Scheduling 最早deadline优先)

> 顾名思义，进程的优先级取决于deadline



### 7.2.5 PSS(按比例分享调度)

> 把CPU使用时间分为T份，让进程来抽奖，抽到几份算几份
>



## 7.3 调度算法的评估

### 7.3.1 为什么&如何要评估调度算法

在涉及调度时，常常需要面对如下的问题：

> 1. 如何为操作系统选择一款CPU调度算法
> 2. 如何选择评价的依据，并评估调度算法的效果



为了根据OS的实际特点选出最合适的调度算法，需要对调度算法进行定量的评估

(常见做法是预设一个任务队列，再通过平均等待时间等数字来评价其效果)



### 7.3.2 确定性模型评估法

#### 7.3.2.1 做法

> 根据需要进行调度的队列，计算队列中每个进程的平均等待时间



e.g. P1:执行时间2s,第3s到达，P2.......。使用SJF调度算法，计算平均等待时间



#### 7.3.2.2 优缺点

###### 优点

> - 快速
> - 计算简单



###### 缺点

> - 只能评估确定的进程序列，不够灵活



### 7.3.3 队列模型评估法

#### 7.3.3.1 思想

> - 把进程到达队列的速度，以及CPU和I/O的请求当成是基于概率的
> - 把计算机系统类比为一个服务器的网络，每个计算机系统都有一个等待执行的进程队列



#### 7.3.3.2 Little's 公式

##### 7.3.3.2.1 公式

$n =  \lambda*W $

> n: 平均队列长度(即进程的个数)
>
> $\lambda$：平均到达率(即新进程到达队列的速度)
>
> W：进程的平均等待时间



##### 7.3.3.2.2 原理

e.g. 队列长度为14，平均到达率为7，则可推导出平均等待时间按为2 seconds



### 7.3.4 模拟法

> 通过模拟出来的计算机系统来进行调度算法的测试和评估，将系统时钟做为变量。
>
> 通过给定的数据调用调度算法，收集相关的统计数字，来评估调度算法



### 7.3.5 实际实现法

> 即使是精确度较高的模拟法，也仍然不够精确。因此，可以直接实现新的调度算法，在真正的系统中评估它的效果
>



# Chap8 死锁-1

## 8.1 死锁的基本概念

### 8.1.1  死锁的定义

> 两个或多个进程在**无限的**等待一个事件，而这个事件只能由其中一个处于等待状态的进程来触发



### 8.1.2 资源

> 计算机系统中，广义的资源包括CPU周期、内存空间、I/O设备......



- 可以使用R~1~,R~2~，......R~m~来表示不同类型的资源
- 每种资源有若干个示例
- 每个进程需要按照特定步骤使用资源：
  - 请求
  - 使用
  - 释放



### 8.1.3 死锁出现的条件

#### 8.1.3.1 互斥操作

> 同时只能由一个进程使用这个资源(比如读取操作就不是互斥的)



#### 8.1.3.2 占有并等待

> 一个进程在持有一个或多个资源的前提下，请求其他进程持有的资源



#### 8.1.3.3 非抢占

> 一个资源的示例只会被进程自愿地释放，而无法被其他进程抢走



#### 8.1.3.4 循环等待

> 对于像{P~0~,P~1~,P~2~,......P~N~}这样的进程集合，满足P1等待P2,P2等待P3，......PN等待P1



## 8.2 资源分配图

### 8.2.1 概念 

> 资源分配图常被用于展示系统中资源的分配情况，由代表进程和资源的节点和代表分配/请求状况的边构成



[<img src="https://s1.ax1x.com/2020/08/18/dufcjO.jpg" alt="dufcjO.jpg" style="zoom:67%;" />](https://imgchr.com/i/dufcjO)



### 8.2.2 节点

节点可以分为两类：

> 1. 进程节点
>
>    代表进程的节点
>
> 2. 资源节点
>
>    代表资源的节点，可能会包含多于一个实例



### 8.2.3 边

#### 8.2.3.1 请求边

> 由进程节点指向资源节点，表示一个进程请求某一个资源的实例



#### 8.2.3.2 分配边

> 由资源节点指向进程节点，表示一个资源的一个实例已被分配个某个进程



### 8.2.4 使用资源分配图判断死锁

###### Scenario1

> 途中没有环：一定没有死锁



###### Scenario2

> 图中有环：可能出现了死锁
>
> - 如果每种资源只有一个实例：出现死锁
> - 如果每种资源多于一个实例：可能出现死锁



## 8.3 解决死锁问题的方法

### 8.3.1 四类方法

#### 8.3.1.1 忽略

> 直接不做对死锁的处理



#### 8.3.1.2 死锁预防

> 打破死锁发生的条件，比如互斥操作等。死锁预防的条件往往比较严格
>
> ==静态的==



#### 8.3.1.3 死锁避免

> 与死锁预防的区别是，不做那么严格的限制，而是使用某些方法来避免进入死锁状态
>
> ==动态的==



#### 8.3.1.4 死锁的检测与恢复

> 以一定的周期检测系统中是否出现死锁并做对应处理



### 8.3.2 死锁预防

>  死锁的预防，需要设定限制以打破发生死锁的四个条件

#### 8.3.2.1 互斥操作

1. 对于某些可以共享的资源，不做互斥锁限制(比如文件的读取)

2. 对于实在是不能共享的资源，采用某些特定手段来解决

   e.g.1 打印机：采用假脱机(Spooling) 技术，只允许打印机的守护程序来代替进程使用打印机资源，从而避免死锁

   e.g.2 对于有些不能使用假脱机技术的资源，可以采用别的手段：

   - 只在必要时分配资源
   - 尽可能减少进程对资源的请求

==无论如何，互斥操作实际上都是较难打破的==

#### 8.3.2.2 占有并等待

> 确保一个进程在请求一个资源的时候不持有其他的资源
>
> 问题：
>
> 1. 如果这个进程需要不止一种资源怎么办？
>
>    在开始时就请求所有的资源
>
> 2. 这种方式有什么缺点？
>
>    资源的利用率低-->一个进程请求的资源很可能不是全程使用的
>
>    可能会导致饥饿-->有的进程始终无法得到资源



#### 8.3.2.3 非抢占

> 此条件不易打破，有些资源无法支持抢占(比如打印机)



#### 8.3.2.4 循环等待

> 给所有资源一个编号，只允许进程按照升序的顺序请求资源

[![dKSqMD.jpg](https://s1.ax1x.com/2020/08/18/dKSqMD.jpg)](https://imgchr.com/i/dKSqMD)



### 8.3.3 死锁避免

#### 8.3.3.1 常用的方法与基本原理

> 死锁避免要求系统拥有额外的优先级信息



最简单的做法是，每个进程都声明自己需要的不同种资源的最大实例数。死锁避免算法会动态检查资源的分配情况，来避免进入循环等待的处境。



#### 8.3.3.2 安全状态

> 系统的安全状态的概念是，如果存在一个进程序列<P~1~,P~2~,......P~n~>，而现有的未分配的系统资源或现有的资源+可以由满足资源要求后执行完毕进程释放的资源能够满足每一个进程的资源需求，则称这个状态为安全状态，否则系统不处于安全状态。



###### 举例

[![dKCPbQ.md.jpg](https://s1.ax1x.com/2020/08/18/dKCPbQ.md.jpg)](https://imgchr.com/i/dKCPbQ)

（只有A处于安全状态）



###### 安全状态的意义

- 系统处于安全状态：不会陷入死锁
- 系统不处于安全状态：==可能==陷入死锁

目的：确保系统始终处于安全状态

[![dKC7R0.jpg](https://s1.ax1x.com/2020/08/18/dKC7R0.jpg)](https://imgchr.com/i/dKC7R0)



#### 8.3.3.3 死锁避免算法

##### 8.3.3.3.1 基本思想

> 当一个进程请求资源时，系统必须判断分配后能否保证系统处于安全状态



主要有两种死锁避免算法：

1. 资源分配图算法

   只适用于每种资源只有一个实例的情况

2. 银行家算法

   适用于每种资源有多个实例的情况



##### 8.3.3.3.2  资源分配图算法

###### 声明边的概念

P~J~-->R~j~：表示进程==可能==j请求资源j，使用==虚线==表示

- 当进程确认请求资源时，声明边会转为请求边，方向不变，线变为实线

- 资源分配到进程后，请求边变换方向，转为分配边
- 资源使用完释放后，分配边再次转为声明边



![dKlbNt.jpg](https://s1.ax1x.com/2020/08/18/dKlbNt.jpg)



###### 思路

> 只有在声明边不会导致环的出现时，才允许声明边转为请求边，请求该资源



###### 示意图

![dK3Giq.jpg](https://s1.ax1x.com/2020/08/18/dK3Giq.jpg)

（此处的P~1~-->R~2~是不会被允许的）



##### :fire:8.3.3.3.3  银行家算法

1. ###### 适用条件

   当系统中每种资源的实例不止一个时(也就是大多数场景)

   

2. ###### 要求

   每个进程需要声明对各类资源的最大使用量

   

3. ###### 相关概念

   **Available:** m维向量，表示系统中m种资源的剩余可用值

   **Max**：nXm维矩阵，表示系统中各个进程需要使用的最大资源数

   **Allocation**：nXm维矩阵，表示系统中各个进程已经得到的资源数

   **Need**：nXm维矩阵，表示系统中各个进程还需要的资源数

   (Tips: Need = Max - Allocation)

4. ###### 思路

5. ###### Safety Algorithm(Resource-Request算法中使用这个算法)

   安全算法的步骤：

   ```java
   1.	Let Work and Finish be vectors of length m and n, respectively.  Initialize:
   /*初始化，把Available赋给Work，所有进程状态都设置为未完成*/
   Work = Available
   Finish [i] = false for i = 0, 1, …, n- 1
   2.	Find an i such that both: 
   /*寻找一个标识为未完成，且Need<Work的进程*/
   (a) Finish [i] = false
   (b) Needi <= Work
   If no such i exists, go to step 4
   /*把该进程结束执行释放的资源加回到Work中，并回到步骤2*/
   3.  Work = Work + Allocationi
       Finish[i] = true
       go to step 2
   4.	If Finish [i] == true for all i, then the system is in a safe state
   /*如果Finish中所有元素均为true，则系统处于安全状态*/
   ```

   

6. ###### Resource-Request Algorithm

   ```java
   /*
   *Requesti指的是进程Pi请求的资源，是一个m维向量
   */
   /*如果Requesti小于Needi，则到第二步，否则出错(请求大于自己所需)*/
   1.	If Requesti <= Needi go to step 2.  Otherwise, raise error condition, since process has exceeded its maximum claim
   /*如果Requesti小于可用资源，则到第三步，否则等待*/
   2.	If Requesti <= Available, go to step3 
   Otherwise Pi  must wait, since resources are not available
   /*假设已经分配，并修改三个矩阵的值，执行安全性算法*/
   3.	Pretend to allocate requested resources to Pi by modifying the state as follows:
   		Available = Available  – Requesti;
   		Allocationi = Allocationi + Requesti;
   		Needi = Needi – Requesti;
   /*安全--> 分配资源*/
   If safe --> the resources are allocated to Pi
   /*不安全--> Pi需要等待，三个矩阵恢复到原先的状态 */
   If unsafe --> Pi must wait, and the old resource-allocation state is restored
   
   ```

   



# Chap9 死锁-2

## 9.1 死锁检测和恢复

### 9.1.1 死锁检测

#### 9.1.1.1 单实例资源死锁检测

> 对于单实例的资源，可以通过wait-for graph来判断是否出现死锁



###### 等待图

- 等待图中的节点是进程
- 如果P~i~指向P~j~，则说明P~i~在等待P~j~



[![dKrDJS.jpg](https://s1.ax1x.com/2020/08/18/dKrDJS.jpg)](https://imgchr.com/i/dKrDJS)

​	

###### 死锁的判断

> 如果途中出现了环，则==必然出现==死锁

[<img src="https://s1.ax1x.com/2020/08/18/dKrWd0.jpg" alt="dKrWd0.jpg" style="zoom:67%;" />](https://imgchr.com/i/dKrWd0)



#### 9.1.1.2 多实例资源死锁检测

> 与安全算法完全一致。在执行完安全算法后，如果Finish数组中仍然有元素为False，则说明系统出现了死锁



#### 9.1.1.3 检测算法使用的注意事项

###### 多久调用一次检测算法

> 取决于系统出现死锁的频率。
>
> - 过于频繁：检测算法消耗系统资源过多
> - 过于不频繁：检测算法有可能检测出过多的死锁



###### 从死锁状态中恢复需要roll back多少个进程

> 每个不邻接的环，需要roll back一个进程



### 9.1.2 死锁恢复(的方式)

#### 9.1.2.1 进程终止

###### 做法1

直接终止所有死锁环涉及的进程



###### 做法2

在死锁环中，一次选中一个进程终止，直到打破死锁状态



###### 选择终止进程的依据

> 1. 优先级
> 2. 这个进程已经执行了多久，还需要执行多久
> 3. 进程占有的资源
> 4. 进程还需要的资源
> 5. 有多少进程需要被终止
> 6. 这个进程是属于交互式的还是批处理的



#### 9.1.2.2 资源抢占

> 1. 选择一个受害者进程，确保消耗最小
> 2. 回收这个进程的资源，回滚到安全状态



###### 问题

有些进程可能常常被跳出来作为受害者，从而产生饥饿问题



## 9.2 实际的死锁解决 

实际中的死锁处理，往往会结合多种不同方式，包括

> - 预防
> - 避免
> - 检测与恢复

具体的使用方式，要结合系统的实际情况。