# Chap6 CPU调度-1

## 6.1 CPU调度的背景

### 6.1.1 需要调度的原因

> 多个进程竞争同时有限的CPU计算资源，所以需要决定哪个进程优先执行



### 6.1.2 何时进行调度(调度发生在进程状态转换的哪个阶段)

[<img src="https://s1.ax1x.com/2020/08/15/dkjKQf.md.jpg" alt="dkjKQf.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dkjKQf)



###### 非抢占的

> 1. 进程从running切换到waiting状态时
> 2. 进程终止时



###### 抢占的

> 1. 进程从waiting切换到ready时
> 2. 进程从running切换到ready时



## 6.2 调度的方法与评价准则

### 6.2.1 如何进行调度

> Dispatcher通过以下步骤将CPU的控制权交给经过短期调度选出的进程
>
> 1. 切换上下文(切换到将要执行的进程对应的上下文)
> 2. 切换为用户模式
> 3. 跳转到用户程序的正确位置来重启程序



[<img src="https://s1.ax1x.com/2020/08/15/dkvChn.md.jpg" alt="dkvChn.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dkvChn)



### 6.2.2 评价准则

#### 6.2.2.1 准则

1. CPU Utilization CPU利用率 

   > 顾名思义，代表CPU的使用效率

2. Throughput 吞吐量

   > 固定时间段内CPU完成计算的进程个数

3. TurnaroundTime 周转时间

   > 对于单个进程，从到达ready队列到执行完毕的时间
   >
   > 等待时间+实际执行花费时间

4. Waiting Time 等待时间

   > 进程执行前在队列中等待的时间

5. Response Time 响应时间

   > 从请求提交到第一个响应产生的时间
   >
   > 对于批处理系统(Batch System):响应时间==周转时间，因为响应就说明计算完成了
   >
   > 对于分时系统(Time-Sharing System):响应时间！=周转时间，因为响应有可能代表计算完成，也有可能仅代表第一个时间片结束

   

#### :fire:6.2.2.2 目标

1. CPU利用率最大化
2. 吞吐量最大化
3. 周转时间最短
4. 等待时间最短
5. 响应时间最短





## 6.3 批处理系统的调度算法

#### 6.3.0 批处理系统的介绍

> 专门用于调度的算法被称为调度算法。
>
> 在批处理系统中，常用的调度算法有以下几个：
>
> 1. FCFS(First Come First Serve)
> 2. SJF(Shortest Job First)
> 3. SRTF(Shortest Remain Time First)
> 4. TL S(Three-Level Scheduling)



#### 6.3.1 FCFS

##### 6.3.1.1 原理

> “先到先服务”，按到达ready序列的顺序计算，是最简单的调度算法

==非抢占==

##### 6.3.1.2 示意图



##### 6.3.1.3 优缺点



#### 6.3.2 SJF

##### 6.3.2.1 原理



==非抢占==

##### 6.3.2.2 示意图



##### 6.3.2.3 优缺点



#### 6.3.3 SRTF

##### 6.3.3.1 原理





==抢占==

##### 6.3.3.2 示意图



##### 6.3.3.3 优缺点



#### 6.3.4 Three-Level



# Chap7 CPU调度-2

## 7.1 交互式系统的调度算法

### 7.1.0 交互式系统的介绍

#### 7.1.1 优先级调度



#### 7.1.2 时间片轮转法调度



#### 7.1.3 多级队列调度



#### 7.1.4 多级反馈队列调度



## 7.2 实时系统的调度算法

### 7.2.1 实时系统的介绍



### 7.2.2 基于优先级的调度



### 7.2.3 RMS



### 7.2.4 EDF



### 7.2.5 PSS





## 7.3 调度算法的评估

### 7.3.1 为什么&如何要评估调度算法



### 7.3.2 确定性模型评估法

#### 7.3.2.1 做法



#### 7.3.2.2 优缺点



### 7.3.3 队列模型评估法

#### 7.3.3.1 思想



#### 7.3.3.2 Little's 公式

##### 7.3.3.2.1 公式



##### 7.3.3.2.2 原理



### 7.3.4 模拟法



### 7.3.5 实际实现法





# Chap8 死锁-1

## 8.1 死锁的基本概念

### 8.1.1  死锁的定义



### 8.1.2 资源



### 8.1.3 死锁出现的条件

#### 8.1.3.1 互斥操作

#### 8.1.3.2 占有并等待

#### 8.1.3.3 非抢占

#### 8.1.3.4 循环等待



## 8.2 资源分配图

### 8.2.1 概念 



### 8.2.2 节点



### 8.2.3 边

#### 8.2.3.1 请求边



#### 8.2.3.2 分配边



### 8.2.4 使用资源分配图判断死锁



## 8.3 解决死锁问题的方法

### 8.3.1 四类方法

#### 8.3.1.1 忽略

#### 8.3.1.2 死锁预防

#### 8.3.1.3 死锁避免

#### 8.3.1.4 死锁的检测与恢复



### 8.3.2 死锁预防

>  死锁的预防，需要设定限制以打破发生死锁的四个条件



#### 8.3.2.1 互斥操作

#### 8.3.2.2 占有并等待

#### 8.3.2.3 非抢占

#### 8.3.2.4 循环等待



### 8.3.3 死锁避免

#### 8.3.3.1 常用的方法与基本原理



#### 8.3.3.2 安全状态



#### 8.3.3.3 死锁避免算法

##### 8.3.3.3.1 基本思想

##### 8.3.3.3.2  资源分配图算法

###### 声明边的概念



###### 思路



###### 示意图



##### 8.3.3.3.3  银行家算法

1. ###### 适用条件

2. ###### 要求

3. ###### 相关概念

4. ###### 思路

5. ###### Safety Algorithm

6. ###### Resource-Request Algorithm





# Chap9 死锁-2

## 9.1 死锁检测和恢复



## 9.2 实际的死锁解决