# Chap6 CPU调度-1

## 6.1 CPU调度的背景

### 6.1.1 需要调度的原因

> 多个进程竞争同时有限的CPU计算资源，所以需要决定哪个进程优先执行



### 6.1.2 何时进行调度(调度发生在进程状态转换的哪个阶段)

[<img src="https://s1.ax1x.com/2020/08/15/dkjKQf.md.jpg" alt="dkjKQf.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dkjKQf)



###### 非抢占的

> 1. 进程从running切换到waiting状态时
> 2. 进程终止时



###### 抢占的

> 1. 进程从waiting切换到ready时
> 2. 进程从running切换到ready时



## 6.2 调度的方法与评价准则

### 6.2.1 如何进行调度

> Dispatcher通过以下步骤将CPU的控制权交给经过短期调度选出的进程
>
> 1. 切换上下文(切换到将要执行的进程对应的上下文)
> 2. 切换为用户模式
> 3. 跳转到用户程序的正确位置来重启程序



[<img src="https://s1.ax1x.com/2020/08/15/dkvChn.md.jpg" alt="dkvChn.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dkvChn)



### 6.2.2 评价准则

#### 6.2.2.1 准则

1. CPU Utilization CPU利用率 

   > 顾名思义，代表CPU的使用效率

2. Throughput 吞吐量

   > 固定时间段内CPU完成计算的进程个数

3. TurnaroundTime 周转时间

   > 对于单个进程，从到达ready队列到执行完毕的时间
   >
   > 等待时间+实际执行花费时间

4. Waiting Time 等待时间

   > 进程执行前在队列中等待的时间

5. Response Time 响应时间

   > 从请求提交到第一个响应产生的时间
   >
   > 对于批处理系统(Batch System):响应时间==周转时间，因为响应就说明计算完成了
   >
   > 对于分时系统(Time-Sharing System):响应时间！=周转时间，因为响应有可能代表计算完成，也有可能仅代表第一个时间片结束

   

#### :fire:6.2.2.2 目标

1. CPU利用率最大化
2. 吞吐量最大化
3. 周转时间最短
4. 等待时间最短
5. 响应时间最短





## 6.3 批处理系统的调度算法

#### 6.3.0 批处理系统的介绍

> 专门用于调度的算法被称为调度算法。
>
> 在批处理系统中，常用的调度算法有以下几个：
>
> 1. FCFS(First Come First Serve)
> 2. SJF(Shortest Job First)
> 3. SRTF(Shortest Remain Time First)
> 4. TL S(Three-Level Scheduling)



#### 6.3.1 FCFS(First Come First Serve)

##### 6.3.1.1 原理

> “先到先服务”，按到达ready序列的顺序计算，是最简单的调度算法

==非抢占==



##### 6.3.1.2 示意图

###### 原理图

[![depJLn.md.jpg](https://s1.ax1x.com/2020/08/17/depJLn.md.jpg)](https://imgchr.com/i/depJLn)

###### 甘特图举例(之后的调度算法略去此图)

[![dmsEHf.md.jpg](https://s1.ax1x.com/2020/08/17/dmsEHf.md.jpg)](https://imgchr.com/i/dmsEHf)



##### 6.3.1.3 优缺点

###### 优点

1.实现简单



###### 缺点

1.不灵活

2.如果执行时间长的进程先进入队列，则有可能导致护航现象(convey effect)出现

Tips:护航现象，指很多进程等待一个大的进程执行完毕释放资源的现象



#### 6.3.2 SJF(Shortest-Job-First)

##### 6.3.2.1 原理

> 最短执行时间作业优先。按照队列中作业的执行时间排序，越短越靠前

==非抢占==

Tips:注意，如果一个执行时间较长的进程已经在执行，则SJF不会抢占计算资源，

##### 6.3.2.2 示意图

[![depXY8.md.jpg](https://s1.ax1x.com/2020/08/17/depXY8.md.jpg)](https://imgchr.com/i/depXY8)

##### 6.3.2.3 优缺点

###### 优点

> 理论上，SJF无疑是最佳的，能够给出最短的平均等待时间



###### 缺点

> 最关键的缺点是，难以预测进程的执行时间是多少：
>
> 1. 对于长期调度：可以通过用户声明的进程时间限制来调度
> 2. 对于短期调度，无法获取



##### 6.3.2.4 预测执行时间

> 在执行时间不知道的情况下，想要使用SJF调度算法，则需要进行预测
>
> 
>
> 预测公式：$\tau_{n+1} = \alpha t_n + (1-\alpha)\tau_n$
>
> $\tau_{n+1} $:对第n+1次CPU执行时间的预测值
>
> t~n~:第n次CPU执行时间的确切值
>
> $\alpha$:[0,1]之间的系数
>
> 当 $\alpha$=0时，上一次CPU执行时间与此次预测毫无关系
>
> 当$\alpha$=1时，直接以上一次的执行时间作为预测值



#### 6.3.3 SRTF(Shortest-Remain-Time-First)

##### 6.3.3.1 原理

> SRTF实际上就是一个抢占版本的SJF



- 永远选中剩余执行时间最短的进程
- 如果一个新来的进程的执行时间比正在执行的进程执行时间还要段，则将抢占CPU资源



==抢占==

##### 6.3.3.2 示意图

和SJF一样，略



#### 6.3.4 Three-Level

##### 6.3.4.1 三级调度的概念

> 在有的操作系统中仅采用一级凋度，而有的操作系统则将凋度分为不同的层次，一个用户作业从进入系统成为后备作业开始，直到运行结退出系统为止，一般最多经历三级调度，即处理器调度可以分为3个层次，分别是高、中、低级调度。



##### 6.3.4.2 示意图

[<img src="https://s1.ax1x.com/2020/08/17/dmsJET.md.jpg" alt="dmsJET.md.jpg" style="zoom:67%;" />](https://imgchr.com/i/dmsJET)





# Chap7 CPU调度-2

## 7.1 交互式系统的调度算法

### 7.1.0 交互式系统的介绍

###### 简介

> 人机交互是指人与计算机之间使用某种对话语言，以一定的交互方式，为完成确定任务的人与机器之间的信息交换过程。基于此，为达到人机交互目的而为机器所编写的操作系统称为交互式操作系统。



###### 系统目标

> 响应时间：能够迅速响应用户的请求
>
> 均衡性：能够满足用户的预期



###### 常见的交互式系统调度算法

> 1. 优先级调度
> 2. 时间片轮转法
> 3. 多级队列调度
> 4. 多级反馈队列调度



### 7.1.1 优先级调度

#### 7.1.1.1 原理

> 每个进程都持有一个优先级，优先级高的会被放置在就绪队列的前面



- 优先级一般是一个固定范围的数字，比如1~10，常用的做法是数字越小，代表优先级越高
- SJF就是一个特殊的例子，相当于队列中所有进程的优先级相等
- 优先级调度可以分为抢占的和非抢占的，可以参考SRTF调度算法



#### 7.1.1.2 示意图

#### 7.1.1.3 优缺点



### 7.1.2 时间片轮转法调度

#### 7.1.2.1 原理

#### 7.1.2.2 示意图

#### 7.1.2.3 优缺点



### 7.1.3 多级队列调度

#### 7.1.3.1 原理

#### 7.1.3.2 示意图

#### 7.1.3.3 优缺点



### 7.1.4 多级反馈队列调度

#### 7.1.4.1 原理

#### 7.1.4.2 示意图

#### 7.1.4.3 优缺点



## 7.2 实时系统的调度算法

### 7.2.1 实时系统的介绍



### 7.2.2 基于优先级的调度



### 7.2.3 RMS



### 7.2.4 EDF



### 7.2.5 PSS





## 7.3 调度算法的评估

### 7.3.1 为什么&如何要评估调度算法



### 7.3.2 确定性模型评估法

#### 7.3.2.1 做法



#### 7.3.2.2 优缺点



### 7.3.3 队列模型评估法

#### 7.3.3.1 思想



#### 7.3.3.2 Little's 公式

##### 7.3.3.2.1 公式



##### 7.3.3.2.2 原理



### 7.3.4 模拟法



### 7.3.5 实际实现法





# Chap8 死锁-1

## 8.1 死锁的基本概念

### 8.1.1  死锁的定义



### 8.1.2 资源



### 8.1.3 死锁出现的条件

#### 8.1.3.1 互斥操作

#### 8.1.3.2 占有并等待

#### 8.1.3.3 非抢占

#### 8.1.3.4 循环等待



## 8.2 资源分配图

### 8.2.1 概念 



### 8.2.2 节点



### 8.2.3 边

#### 8.2.3.1 请求边



#### 8.2.3.2 分配边



### 8.2.4 使用资源分配图判断死锁



## 8.3 解决死锁问题的方法

### 8.3.1 四类方法

#### 8.3.1.1 忽略

#### 8.3.1.2 死锁预防

#### 8.3.1.3 死锁避免

#### 8.3.1.4 死锁的检测与恢复



### 8.3.2 死锁预防

>  死锁的预防，需要设定限制以打破发生死锁的四个条件



#### 8.3.2.1 互斥操作

#### 8.3.2.2 占有并等待

#### 8.3.2.3 非抢占

#### 8.3.2.4 循环等待



### 8.3.3 死锁避免

#### 8.3.3.1 常用的方法与基本原理



#### 8.3.3.2 安全状态



#### 8.3.3.3 死锁避免算法

##### 8.3.3.3.1 基本思想

##### 8.3.3.3.2  资源分配图算法

###### 声明边的概念



###### 思路



###### 示意图



##### 8.3.3.3.3  银行家算法

1. ###### 适用条件

2. ###### 要求

3. ###### 相关概念

4. ###### 思路

5. ###### Safety Algorithm

6. ###### Resource-Request Algorithm





# Chap9 死锁-2

## 9.1 死锁检测和恢复



## 9.2 实际的死锁解决