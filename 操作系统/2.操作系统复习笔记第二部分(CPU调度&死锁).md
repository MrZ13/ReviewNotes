# Chap6 CPU调度-1

## 6.1 CPU调度的背景

### 6.1.1 需要调度的原因

> 多个进程竞争同时有限的CPU计算资源，所以需要决定哪个进程优先执行



### 6.1.2 何时进行调度(调度发生在进程状态转换的哪个阶段)

[<img src="https://s1.ax1x.com/2020/08/15/dkjKQf.md.jpg" alt="dkjKQf.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dkjKQf)



###### 非抢占的

> 1. 进程从running切换到waiting状态时
> 2. 进程终止时



###### 抢占的

> 1. 进程从waiting切换到ready时
> 2. 进程从running切换到ready时



## 6.2 调度的方法与评价准则

### 6.2.1 如何进行调度

> Dispatcher通过以下步骤将CPU的控制权交给经过短期调度选出的进程
>
> 1. 切换上下文(切换到将要执行的进程对应的上下文)
> 2. 切换为用户模式
> 3. 跳转到用户程序的正确位置来重启程序



[<img src="https://s1.ax1x.com/2020/08/15/dkvChn.md.jpg" alt="dkvChn.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dkvChn)



### 6.2.2 评价准则

#### 6.2.2.1 准则

1. CPU Utilization CPU利用率 

   > 顾名思义，代表CPU的使用效率

2. Throughput 吞吐量

   > 固定时间段内CPU完成计算的进程个数

3. TurnaroundTime 周转时间

   > 对于单个进程，从到达ready队列到执行完毕的时间
   >
   > 等待时间+实际执行花费时间

4. Waiting Time 等待时间

   > 进程执行前在队列中等待的时间

5. Response Time 响应时间

   > 从请求提交到第一个响应产生的时间
   >
   > 对于批处理系统(Batch System):响应时间==周转时间，因为响应就说明计算完成了
   >
   > 对于分时系统(Time-Sharing System):响应时间！=周转时间，因为响应有可能代表计算完成，也有可能仅代表第一个时间片结束

   

#### :fire:6.2.2.2 目标

1. CPU利用率最大化
2. 吞吐量最大化
3. 周转时间最短
4. 等待时间最短
5. 响应时间最短





## :fire:6.3 批处理系统的调度算法

#### 6.3.0 批处理系统的介绍

> 专门用于调度的算法被称为调度算法。
>
> 在批处理系统中，常用的调度算法有以下几个：
>
> 1. FCFS(First Come First Serve)
> 2. SJF(Shortest Job First)
> 3. SRTF(Shortest Remain Time First)
> 4. TL S(Three-Level Scheduling)



#### :zap: 6.3.1 FCFS(First Come First Serve)

##### 6.3.1.1 原理

> “先到先服务”，按到达ready序列的顺序计算，是最简单的调度算法

==非抢占==



##### 6.3.1.2 示意图

###### 原理图

[![depJLn.md.jpg](https://s1.ax1x.com/2020/08/17/depJLn.md.jpg)](https://imgchr.com/i/depJLn)

###### 甘特图举例(之后的调度算法略去此图)

[![dmsEHf.md.jpg](https://s1.ax1x.com/2020/08/17/dmsEHf.md.jpg)](https://imgchr.com/i/dmsEHf)



##### 6.3.1.3 优缺点

###### 优点

1.实现简单



###### 缺点

1.不灵活

2.如果执行时间长的进程先进入队列，则有可能导致护航现象(convey effect)出现

Tips:护航现象，指很多进程等待一个大的进程执行完毕释放资源的现象



#### :zap:6.3.2 SJF(Shortest-Job-First)

##### 6.3.2.1 原理

> 最短执行时间作业优先。按照队列中作业的执行时间排序，越短越靠前

==非抢占==

Tips:注意，如果一个执行时间较长的进程已经在执行，则SJF不会抢占计算资源，

##### 6.3.2.2 示意图

[![depXY8.md.jpg](https://s1.ax1x.com/2020/08/17/depXY8.md.jpg)](https://imgchr.com/i/depXY8)

##### 6.3.2.3 优缺点

###### 优点

> 理论上，SJF无疑是最佳的，能够给出最短的平均等待时间



###### 缺点

> 最关键的缺点是，难以预测进程的执行时间是多少：
>
> 1. 对于长期调度：可以通过用户声明的进程时间限制来调度
> 2. 对于短期调度，无法获取



##### 6.3.2.4 预测执行时间

> 在执行时间不知道的情况下，想要使用SJF调度算法，则需要进行预测
>
> 
>
> 预测公式：$\tau_{n+1} = \alpha t_n + (1-\alpha)\tau_n$
>
> $\tau_{n+1} $:对第n+1次CPU执行时间的预测值
>
> t~n~:第n次CPU执行时间的确切值
>
> $\alpha$:[0,1]之间的系数
>
> 当 $\alpha$=0时，上一次CPU执行时间与此次预测毫无关系
>
> 当$\alpha$=1时，直接以上一次的执行时间作为预测值



#### :zap:6.3.3 SRTF(Shortest-Remain-Time-First)

##### 6.3.3.1 原理

> SRTF实际上就是一个抢占版本的SJF



- 永远选中剩余执行时间最短的进程
- 如果一个新来的进程的执行时间比正在执行的进程执行时间还要段，则将抢占CPU资源



==抢占==

##### 6.3.3.2 示意图

和SJF一样，略



#### 6.3.4 Three-Level

##### 6.3.4.1 三级调度的概念

> 在有的操作系统中仅采用一级凋度，而有的操作系统则将凋度分为不同的层次，一个用户作业从进入系统成为后备作业开始，直到运行结退出系统为止，一般最多经历三级调度，即处理器调度可以分为3个层次，分别是高、中、低级调度。



##### 6.3.4.2 示意图

[<img src="https://s1.ax1x.com/2020/08/17/dmsJET.md.jpg" alt="dmsJET.md.jpg" style="zoom:67%;" />](https://imgchr.com/i/dmsJET)





# Chap7 CPU调度-2

## 7.1 交互式系统的调度算法

### 7.1.0 交互式系统的介绍

###### 简介

> 人机交互是指人与计算机之间使用某种对话语言，以一定的交互方式，为完成确定任务的人与机器之间的信息交换过程。基于此，为达到人机交互目的而为机器所编写的操作系统称为交互式操作系统。



###### 系统目标

> 响应时间：能够迅速响应用户的请求
>
> 均衡性：能够满足用户的预期



###### 常见的交互式系统调度算法

> 1. 优先级调度
> 2. 时间片轮转法
> 3. 多级队列调度
> 4. 多级反馈队列调度



### 7.1.1 优先级调度(Priority)

#### 7.1.1.1 原理

> 每个进程都持有一个优先级，优先级高的会被放置在就绪队列的前面



- 优先级一般是一个固定范围的数字，比如1~10，常用的做法是数字越小，代表优先级越高
- SJF就是一个特殊的例子，相当于队列中所有进程的优先级相等
- 优先级调度可以分为抢占的和非抢占的，可以参考SRTF调度算法



#### 7.1.1.2 示意图

P2-->P4的执行遵照优先级的顺序

![dn4uEd.jpg](https://s1.ax1x.com/2020/08/18/dn4uEd.jpg)

#### 7.1.1.3 优缺点

###### 优点

1. 实现起来比SRTF更加简单
2. 支持选择抢占/非抢占的方式实现



###### 缺点

低优先级的进程可能会陷入饥饿状态/无限等待状态，即永远在等待更高优先级的进程执行



### :fire:7.1.2 时间片轮转法调度(Round-Robin)

#### 7.1.2.1 原理

> 为了防止优先级调度导致的饥饿问题，给每一个进程一个最大的执行时间。当执行时间结束，而此进程还没执行完的话，则它会被挂起，让出CPU资源供下一个进程使用



#### 7.1.2.2 示意图

[<img src="https://s1.ax1x.com/2020/08/18/dnTZRI.md.jpg" alt="dnTZRI.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dnTZRI)



#### 7.1.2.3 特点

假设时间片的大小为q

Q很大：时间片轮转法趋近于FCFS，因为大部分进程都能一次执行完

Q很小：进程切换时的上下文切换耗费时间显著提升(注意，q至少应该大于上下文切换的时间)





### 7.1.3 多级队列调度

#### 7.1.3.1 原理

> 如果进程可以方便地进行分组的话，那么可以将不同进程放入不同优先级的队列中，而每个队列又可以采取不一样的调度算法，从而灵活地进行调度



#### 7.1.3.2 示意图

[![dnT2y6.jpg](https://s1.ax1x.com/2020/08/18/dnT2y6.jpg)](https://imgchr.com/i/dnT2y6)



#### 7.1.3.3 优缺点

###### 优点

能够根据不同的优先级选择不同的调度方式



###### 缺点

不支持进程在不同的队列之间移动，仍然缺少一些灵活性





### 7.1.4 多级反馈队列调度

#### 7.1.4.1 原理

> 多级反馈队列就是支持进程在不同队列间移动的多级队列调度算法
>
> 1. 如果一个进程使用了过多的CPU时间，则它将会被移动到低优先级的队列中
> 2. 如果一个进程长时间处于低优先级的队列中，则它会被提到高优先级的队列中



#### 7.1.4.2 示意图

[![dnHZKP.md.jpg](https://s1.ax1x.com/2020/08/18/dnHZKP.md.jpg)](https://imgchr.com/i/dnHZKP)



#### 7.1.4.3 实现

> 多级反馈队列的实现被如下的方法/参数定义
>
> 1. 队列的个数
> 2. 每个队列中使用的调度算法
> 3. 提高进程优先级的方法
> 4. 降低进程优先级的方法
> 5. 决定把新来的进程放入哪个队列的方法



## 7.2 实时系统的调度算法

### 7.2.1 实时系统的介绍

> 一个实时系统是指计算的正确性不仅取决于程序的逻辑正确性，也取决于结果产生的时间，如果系统的时间约束条件得不到满足，将会发生系统出错。



###### 软实时系统

> 关键的实时任务拥有最高的优先级，但软实时系统不保证任务执行的时间



###### 硬实时系统

> 任务必须在deadline之前结束执行



###### 事件延迟(Event Latency)

> 事件从到达到被响应中间间隔的时间
>
> 两种类型的延迟：
>
> 1. 中断延迟(Interrupt Latency)
>
>    系统产生中断导致的延迟
>
> 2. 分配延迟(Dispatch Latency)
>
>    系统切换执行的进程导致的延迟



### 7.2.2 基于优先级的调度

> 对于实时操作系统来说，它必须支持==抢占的==，==基于优先级的==调度算法(但是只支持到软实时程度，硬实时需要硬件来保障)



### 7.2.3 RMS(单调速率调度)

> 一个进程的优先级由它来到系统的次数来决定
>
> - 越频繁来到系统的进程：优先级低
> - 越不频繁来到系统的进程：优先级高



### 7.2.4 EDF(Earliest Deadline First Scheduling 最早deadline优先)

> 顾名思义，进程的优先级取决于deadline



### 7.2.5 PSS(按比例分享调度)

> 把CPU使用时间分为T份，让进程来抽奖，抽到几份算几份
>



## 7.3 调度算法的评估

### 7.3.1 为什么&如何要评估调度算法

在涉及调度时，常常需要面对如下的问题：

> 1. 如何为操作系统选择一款CPU调度算法
> 2. 如何选择评价的依据，并评估调度算法的效果



为了根据OS的实际特点选出最合适的调度算法，需要对调度算法进行定量的评估

(常见做法是预设一个任务队列，再通过平均等待时间等数字来评价其效果)



### 7.3.2 确定性模型评估法

#### 7.3.2.1 做法

> 根据需要进行调度的队列，计算队列中每个进程的平均等待时间



e.g. P1:执行时间2s,第3s到达，P2.......。使用SJF调度算法，计算平均等待时间



#### 7.3.2.2 优缺点

###### 优点

> - 快速
> - 计算简单



###### 缺点

> - 只能评估确定的进程序列，不够灵活



### 7.3.3 队列模型评估法

#### 7.3.3.1 思想

> - 把进程到达队列的速度，以及CPU和I/O的请求当成是基于概率的
> - 把计算机系统类比为一个服务器的网络，每个计算机系统都有一个等待执行的进程队列



#### 7.3.3.2 Little's 公式

##### 7.3.3.2.1 公式

$n =  \lambda*W $

> n: 平均队列长度(即进程的个数)
>
> $\lambda$：平均到达率(即新进程到达队列的速度)
>
> W：进程的平均等待时间



##### 7.3.3.2.2 原理

e.g. 队列长度为14，平均到达率为7，则可推导出平均等待时间按为2 seconds



### 7.3.4 模拟法

> 通过模拟出来的计算机系统来进行调度算法的测试和评估，将系统时钟做为变量。
>
> 通过给定的数据调用调度算法，收集相关的统计数字，来评估调度算法



### 7.3.5 实际实现法

> 即使是精确度较高的模拟法，也仍然不够精确。因此，可以直接实现新的调度算法，在真正的系统中评估它的效果
>



# Chap8 死锁-1

## 8.1 死锁的基本概念

### 8.1.1  死锁的定义



### 8.1.2 资源



### 8.1.3 死锁出现的条件

#### 8.1.3.1 互斥操作

#### 8.1.3.2 占有并等待

#### 8.1.3.3 非抢占

#### 8.1.3.4 循环等待



## 8.2 资源分配图

### 8.2.1 概念 



### 8.2.2 节点



### 8.2.3 边

#### 8.2.3.1 请求边



#### 8.2.3.2 分配边



### 8.2.4 使用资源分配图判断死锁



## 8.3 解决死锁问题的方法

### 8.3.1 四类方法

#### 8.3.1.1 忽略

#### 8.3.1.2 死锁预防

#### 8.3.1.3 死锁避免

#### 8.3.1.4 死锁的检测与恢复



### 8.3.2 死锁预防

>  死锁的预防，需要设定限制以打破发生死锁的四个条件



#### 8.3.2.1 互斥操作

#### 8.3.2.2 占有并等待

#### 8.3.2.3 非抢占

#### 8.3.2.4 循环等待



### 8.3.3 死锁避免

#### 8.3.3.1 常用的方法与基本原理



#### 8.3.3.2 安全状态



#### 8.3.3.3 死锁避免算法

##### 8.3.3.3.1 基本思想

##### 8.3.3.3.2  资源分配图算法

###### 声明边的概念



###### 思路



###### 示意图



##### 8.3.3.3.3  银行家算法

1. ###### 适用条件

2. ###### 要求

3. ###### 相关概念

4. ###### 思路

5. ###### Safety Algorithm

6. ###### Resource-Request Algorithm





# Chap9 死锁-2

## 9.1 死锁检测和恢复



## 9.2 实际的死锁解决 