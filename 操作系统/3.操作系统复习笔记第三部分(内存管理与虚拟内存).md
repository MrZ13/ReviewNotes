# Chap10 内存管理

## 10.1 相关背景

> - 程序需要被CPU从Disk中带到Memory中，并放置在一个进程中，以便运行
> - 主存和寄存器是CPU能直接访问的介质
>   - Cache在CPU和主存之间，保存常用的一些数据
>   - 对内存的保护即是确保操作是正确的(比如一般情况下，一个进程不能访问另一个进程的地址空间)



### 10.1.1 地址空间保护

> 需要确保一个进程只能访问它自己的地址空间
>
> - 可以通过一个基地址寄存器和一个限制地址寄存器达到目的

<img src="https://s1.ax1x.com/2020/08/19/dQ8c4A.jpg" alt="dQ8c4A.jpg" style="zoom:67%;" />



> CPU必须检查每个内存访问请求，确保访问的地址在[base,base+limit]这个范围中

![dQ8vuT.jpg](https://s1.ax1x.com/2020/08/19/dQ8vuT.jpg)



### 10.1.2 地址绑定

> 程序是存储在磁盘中的，需要被带到主存中才能执行。在地址绑定的过程，实际上就是将程序中使用的变量、数据等，逐层绑定到实际的地址空间上，从而使得进程可以操作这些数据



### 10.1.3 地址的不同表示与绑定时间

###### 不同表示

> - 源码：使用符号表示，比如"int x"
> - 编译后的代码：绑定到可重定位地址上,比如"此模块的其实地址后14byte的位置"
> - 链接器或装载器绑定后：绑定到实际的地址上



###### 绑定时间

> - 编译时绑定：编译时如果就已经知道程序在内存中的驻留地址，则可以此时绑定(==少见==)
> - 装载时绑定：如果编译时不知道，则需要在装载时生成可重定位地址(==常见==)
> - 运行时绑定：如果程序在运行时可以从内存段中被移动，则绑定需要延迟到这一时刻(==相对少见==)



### 10.1.4 逻辑地址空间 VS 物理地址空间

> 从逻辑地址空间到物理地址空间的绑定，是内存管理的关键



- 逻辑地址：由CPU生成，也被称为虚拟地址
- 逻辑地址空间：逻辑地址的集合



- 物理地址：能够被实际的内存单元看到的地址
- 物理地址空间 ：物理地址的集合



### 10.1.5 MMU

> MMU: Memory-Management Unit ，内存管理单元

![dQJX0U.jpg](https://s1.ax1x.com/2020/08/19/dQJX0U.jpg)



#### 10.1.5.1 MMU的作用

> MMU负责将逻辑地址映射到物理地址



现在，回忆一下10.1.1中提到的base(基地址寄存器)，现在将其称为relocation(重定位寄存器)

- 每次遇到程序提供的地址时，加上relocation中的值，从而得到实际的地址
- 用户程序从来不直接接触物理地址，都是靠MMU进行匹配



#### 10.1.5.2 示例

![dQY7Ue.jpg](https://s1.ax1x.com/2020/08/19/dQY7Ue.jpg)



### 10.1.6 动态装载

> 执行程序时，整个程序不需要被一次直接全部放入内存

- 所有的磁盘上的子程序的地址是可重定位格式的
- 子程序不被调用，就不装载
- 适用于程序较大，但有些部分不是频繁被调用的情况
- 能够获得更好的内存空间利用率
- 不需要OS提供额外的支持，在程序处实现即可



### 10.1.7 动态链接

静态链接：系统的库和程序的代码直接结合

动态链接：链接被延迟，直到执行时才链接

- 使用较小的代码片段——stub，将不在内存中的子程序装入对应的链接库，以便定位到正确的子程序
- 在执行时，stub用子程序的地址来替换自己



Tips:动态链接在库(libraries)中广泛使用



## 10.2 内存管理模式

### 10.2.1 概述

> 内存管理的实际意义，即是为进程分配内存空间，使得进程能够执行。
>
> 由于内存空间是有限的，因此必须找到合适的方法，尽可能提高内存资源的利用率。



![dQU2CQ.jpg](https://s1.ax1x.com/2020/08/19/dQU2CQ.jpg)



### 10.2.2 连续空间分配

#### 10.2.2.1 概念

连续空间分配是一种早期的内存管理机制



- OS常驻在内存中，一般驻留在低地址空间。中断向量也被放置在低地址
- 用户程序一般被放置在高地址空间
- 每个进程都持有一段内存中连续的空间



使用可重定位寄存器(reloaction)/基地址寄存器(base)和界限寄存器(limit)

- relocation/base register: 持有物理地址的最小值
- limit register:持有==逻辑地址==的范围



[![dQsEY6.md.jpg](https://s1.ax1x.com/2020/08/19/dQsEY6.md.jpg)](https://imgchr.com/i/dQsEY6)

(只有在逻辑地址不越界的前提下，才能和基地址相加，获取物理地址)

#### 10.2.2.2 单一分区与多分区

> 单一分区：顾名思义，内存只有一个分区
>
> 多分区：内存有多个分区，又分为固定大小分区和可变大小分区



#### 10.2.2.3 可变大小分区(多分区的一种)

##### 10.2.2.3.1 概念

> - 多道程序的度由分区的个数决定
> - 孔(Hole):一块可用的空间，不同大小的孔分布在内存的不同位置
>
> -  当一个进程到达时，为它分配一个足够大的孔
>
> - 当进程释放内存资源时，不同大小的孔会合并



操作系统需要维护：

1. 已分配的孔
2. 可以分配的孔



##### 10.2.2.3.2 动态存储分配问题

> 问题：如何给进程选出合适的孔



###### 不同的分配方法

> 1. First-Fit：第一个放得下的孔
> 2. Best-Fit：放得下的前提下找最小的
> 3. Worst-Fit：最大的孔



##### 10.2.2.3.3 碎片问题

###### 外部碎片

> 总共的剩余空间可以放得下进程，但这些空间不连续
>
> **解决：**通过紧缩解决——把所有空闲的内存集中到一起
>
> - 只有当进程是动态可重定位时，才能进行，且需要在运行时完成
>   - ==原因==：因为这就是进程需要从一个内存段移到另一个内存段的情况，地址绑定必须延迟到运行时
>
> 
>
> 关于I/O的问题：如果一个进程执行到I/O操作，则将其在内存中锁定，并通过缓冲(buffer)进行I/O操作



###### 内部碎片

> 分配给一个进程的空间没有用完，有一部分闲置

(**只有固定分区中，才会出现内部碎片**)



### 10.2.3 非连续空间分配

> 进程使用的物理地址空间可以是不连续的，当有足够的内存空间时，就可以为进程分配
>
> 分配时的注意事项：
>
> - 避免外部碎片
> - 避免不同大小内存块带来的问题



####  10.2.3.1 分页(Pageing)

#####  10.2.3.1.1 分页的概念

**页**：逻辑内存的分配单位，一个进程使用的内存资源以页为单位计算，==大小必须和帧保持一致==

**帧**：物理内存的分配单位



为了进行从逻辑地址到物理地址的转换，需要使用**页表**



#####  10.2.3.1.2 做法简介

==注意区分CPU生成的逻辑地址格式和页表记录格式的区别==

###### 1.地址转换方式

**CPU产生的逻辑地址格式**

| Page Number | Page Offset |
| :---------: | :---------: |
|      p      |      d      |

意义：页表中第p页的第d项



**页表格式**

==注意：PageNumber实际上就是页表的数组下标，因此页表实际上是一维的==

| Page Number | Frame Number |
| :---------: | :----------: |
|      m      |      n       |

意义：页表中第m页对应物理内存第n帧



**:fire:寻址过程**

1. 根据p确定m
2. 根据m确定n
3. n+d，确定物理地址



###### 2.示意图

[![dlkt8H.md.jpg](https://s1.ax1x.com/2020/08/19/dlkt8H.md.jpg)](https://imgchr.com/i/dlkt8H)



###### 3.内部碎片大小计算

e.g. 页的大小是2048bytes 进程大小是72766bytes

内部碎片计算：

72766 % 2048 = 1086bytes

2048 - 1086 = 962bytes

-->内部碎片大小为962bytes



###### 4.Page-Table的实现

> 页表保存于主存中



(1)方式1：PTBR&PTLR

PTBR(Page-Table Base Register)

> 页表基地址寄存器：指向页表的基地址



PTLR(Page-Table Length Register)

> 页表长度寄存器：保存页表的长度信息



**问题**

> 只采用这种方式获取页表，每次需要访问两次主存，延迟比较明显



(2)方式2：TLB

TLB(Translation Look-Aside Buffer)

> 转换缓冲：小而昂贵的硬件缓冲，存储页表的一部分信息。访问速度显著高于主存



- 有些TLB会保存ASIDs(Address-Space Indentifiers)，用于唯一标识每个进程，来起到内存保护的作用
- 如果TLB中的查询没有结果，就会去实际的页表中查询，并将结果放入TLB，以便提高下次访问的速度

![dlZUFf.jpg](https://s1.ax1x.com/2020/08/19/dlZUFf.jpg)





(3)Associated Memory

> 与TLB的作用类似，也是一种普通页表之外的查询方式





###### 5.有效访问时间

EAT(Effective Access Time)

> EAT= TLB访问时间xTLB命中率 + 页表访问时间x(1-TLB命中率) 



###### 6.内存保护

> **帧的保护**
>
> 可以通过一位专门的和frame关联的保护位来实现，由保护位声明帧是只读的，还是同时有读写的权限
>
> 
>
> **页的保护**
>
> 页表中的每一项有一个合法/非法位，用于确定这个页是否在进程的逻辑地址空间中
>
> (或者也可以使用PTLR)





###### 7.页表的不同结构

(1)共享页

> 与线程共享进程的资源类似，对于只读的页，可以多个进程共享



<img src="https://s1.ax1x.com/2020/08/19/dlMCJx.jpg" alt="dlMCJx.jpg" style="zoom:67%;" />



> 页表本身也要占用存内存资源，如果页表很大，则其占用的连续内存资源也比较大，因此，有以下几种页表结构用于解决这个问题

(2)多级页表

> 相当于”给页表建立页表“
>
> ![dlQuB4.jpg](https://s1.ax1x.com/2020/08/19/dlQuB4.jpg)



(3)哈希页表

采用哈希表的形式存储页表(一般适用于地址空间大于32bits的情况)

![dl1FS0.md.jpg](https://s1.ax1x.com/2020/08/19/dl1FS0.md.jpg)

(4)反向页表

传统做法：进程持有页表，页表保存到帧的引用

反向页表做法：==系统==持有页表，每个条目直接指向帧（需要一个额外的标识符来确保页表条目和进程的正确对应）



![dl1EOU.jpg](https://s1.ax1x.com/2020/08/19/dl1EOU.jpg)

###### 8.交换

(1) 交换的概念

> 一个进程可以暂时地从主存中被换出去，并在将来从disk中放回主存，接着执行。交换也可以被称为滚入和滚出操作。

<img src="https://s1.ax1x.com/2020/08/19/dlncTI.jpg" alt="dlncTI.jpg" style="zoom:67%;" />



(2) 地址空间

> :fire:问题：换回到内存中时，是否需要放回原先的地址空间？
>
> 1. Scenario1：编译或加载时绑定：需要换回源地址
> 2. Scenario2：运行时绑定：不需要



(3) 上下文切换时间的减少

进行交换时，主要的时间耗费在进程在主存和磁盘间的转移，可以通过==确定每个进程真正使用的主存空间==来减少。



# Chap11 虚拟内存-1

## 11.1 虚拟内存的背景

### 11.1.1 不把整个程序放入主存

> 代码需要被放入主存才能执行，但不需要整个程序完整地放入才能执行。因此，考虑将部分代码放入内存并执行



### 11.1.2 好处

1. 减小对内存的依赖
2. 提高能够并发执行的进程个数
3. 减少I/O操作，提高运行效率
4. 进程创建操作效率更高



## 11.2 虚拟内存简介

### 11.2.1 概念

> 虚拟内存是指具有请求调页和页置换功能，能够在逻辑上对内存容量进行扩充的技术。虚拟内存将用户逻辑内存与物理内存分离开来。



### 11.2.2 好处

1. 减小对内存的依赖
2. 提高能够并发执行的进程个数
3. 减少I/O操作，提高运行效率
4. 进程创建操作效率更高
5. 逻辑地址空间能够显著大于物理地址空间



## 11.3 虚拟内存的重要概念

### 11.3.1 虚拟地址空间

> 虚拟地址空间是一种对进程在主存中存储方式的逻辑观点。
>
> - 虚拟地址空间往往从零开始，且是连续的
> - 同时，物理内存是以页，帧的形式组织的
> - MMU用于在逻辑地址和物理地址间进行转换



Tips:实现虚拟内存主要有两种方式

1. 按需分页
2. 按需分段



### 11.3.2 按需调页

#### 11.3.2.1 概念

> 程序是按照页划分的，因此相比于把整个进程放入主存，可以只在需要某一页时将其放入内存
>
> 需要某一页：
>
> - 不合法引用(比如引用了别的进程的页)：放弃
> - 不在主存中：调入主存



Tips:按需调页的概念类似于拥有交换功能的分页系统





#### 11.3.2.2 优势

1. 减少不必要的I/O操作
2. 更低的主存需求
3. 更快的响应
4. 支持更多用户



#### 11.3.2.3 特点

###### Lazy Swapper

> 在一个页被需要以前，绝不调入主存



###### Page Fault

> 通过页错误来实现对页的调入



#### 11.3.2.4 合法/非法位

> 每个页表中的条目都有一位新的位：合法/非法位
>
> V---> 此页已在主存中
>
> i---> 不在主存中

- 初始时，所有条目都设为i

- 如果MMU执行地址转换时发现页表中记录为i，就说明出现了页错误



#### :fire:11.3.2.5 处理页错误

> 出现页错误，即说明有需要使用的页不在主存中，需要进行处理



##### :zap:11.3.2.5.1 六个步骤

1. 如果需要使用一个页，首次使用时会向OS发送一个trap信号
2. OS判断这个信号是否是合法的
   - 非法：抛弃
   - 合法：调入对应页到内存中
3. 寻找可用的帧
4. 把页换入主存的帧中
5. 将页表中对应记录的合法/非法位改为v
6. 重新执行导致页错误的指令





##### 11.3.2.5.2 示意图

![dl27DO.jpg](https://s1.ax1x.com/2020/08/19/dl27DO.jpg)

##### 11.3.2.5.3 其他分析

###### 极端情况——在没有调入任何一页的情况下运行进程

> - OS设置对一个进程首条指令的引用-->引发第一个页错误
> - 其他进程也是一样
> - 这种称为纯粹的按需调页



###### 不止一个页错误

> 实际上，一条指令可能会导致出现多个页错误。比如加法指令，需要取不同地方的值相加。



#### 11.3.2.6 空闲帧列表

- OS会维护一个空闲帧链表，每次需要获取空闲帧时，从链表的头部获取
- OS一般情况下会使用按需填0(zero-fill-on-demand)来进行空闲帧的分配



#### 11.3.2.7 按需调页的性能

###### 三个主要的事件

> 1. 处理中断
> 2. ==读取页==(耗费最多资源的过程)
> 3. 重启进程



###### 页错误率——p

> p==0 一个页错误都没有
>
> p==1 全是页错误



###### EAT(Effective Access Time)

> EAT = (1 - p)x memory access + p x (**page fault overhead** + **swap page out** + **swap page in** )



#### 11.3.2.8 优化

##### 11.3.2.8.1 使用交换空间

> 交换空间是一个特殊的磁盘空间，对这个空间的I/O操作比对文件系统的I/O操作更快

在进程装载时，把整个进程的镜像放入交换空间中，然后每次发生页错误时，从交换空间中进行页的读取



##### 11.3.2.8.2 直接抛弃

> 在disk中读取页，但使用完后，如果没有发生变化，就不存入disk中，而是直接抛弃(发生更改才写入disk)



##### 11.3.2.8.3 写时复制(Copy-On-Write)

> 允许父进程和子进程共享相同的页，直到需要对该页进行更改时，才复制处一份用于更改

Tips:总的来说，空闲的页是从按需填零的页的池中选出的

[<img src="https://s1.ax1x.com/2020/08/19/dlb7rj.jpg" alt="dlb7rj.jpg" style="zoom:67%;" />](https://imgchr.com/i/dlb7rj)

​	

#### 11.3.2.9 没有空闲帧的情况(页置换的简介)

##### 11.3.2.9.1 背景

> 有时，系统主存中的帧被用完了，没有可用的空闲帧。这时，如果有新的页错误，就需要进行页置换，来获取空闲帧。

通过页置换算法，确定victim帧，把它从主存中换出，从而获得空闲帧



##### 11.3.2.9.2 示意图

[![dlqcSU.jpg](https://s1.ax1x.com/2020/08/19/dlqcSU.jpg)](https://imgchr.com/i/dlqcSU)



##### 11.3.2.9.3 处理步骤

1. 找到目标页在磁盘上的位置
2. 寻找空闲帧
   - 有空闲帧：直接使用
   - 无空闲帧：选出victim帧，换出，腾出空闲帧
3. 把目标页放入空闲帧中，更新页表
4. 重启导致页错误的指令



##### 11.3.2.9.4 页置换的收益

1. 防止过度分配(指分配的资源>系统拥有的资源)
2. 使用脏位来标识页，只将更改过的页存回disk
3. 支持使用相对小的物理内存空间支持较大的虚拟内存空间



