# Chap6.搜索

## 6.1 搜索问题

### 6.1.1 搜索表

> 搜索表是存储待搜索元素的集合



搜索表可以分为静态搜索表和动态搜索表

###### 静态搜索表

> 静态搜索表中的元素是不改变的
>
> e.g. 数组，集合，......



###### 动态搜索表

> 动态搜索表中的元素不仅可以被搜索，还可以进行更改
>
> e.g. 堆，二叉搜索树，......



### 6.1.2 概念

> 给定搜索关键字(Key)，在搜索表中寻找对应的元素，并返回元素或下标
>
> 如果结果重复，则返回任意一个均可



### 6.1.3  评价搜索效率的数字

常用的搜索效率评价数字有以下几个：

> 1. 不成功搜索比较次数(遍历所有元素)
> 2. worst-case比较次数
> 3. average比较次数





## 6.2 顺序搜索

### 6.2.1 使用的表

> 对于顺序搜索，使用数组存储未排序的元素即可



### 6.2.2 代码 

###### 节点定义

```java
static search table
class Node<Type> {
  Type key; //关键码
   others; //其他域
   public Node( const Type & value ) : key ( value ) { }
   public Type getKey ( ) const { return key; } //读关键码
   public void setKey ( Type k ) { key = k; } //修改关键码
}
```



顺序搜索较简单，其他的代码略



### 6.2.3 复杂度分析

###### 成功比较次数

> 1. best：1
>
> 2. worst：n
>
> 3. average： (nP1+(n-1)P2+...+1*Pn)/n 
>
>    因为在各个位置上出现的几率相等，所以P1=P2=...=Pn=1/n
>
>    average=(n+1)/2



###### 不成功比较次数

> n+1：原因是回到下标为0的元素处时，做了最后一次比较操作



###### 平均比较次数

> (n+1)/2/2+(n+1)/2=3*(n+1)/4



### 6.2.4 优缺点

#### 优点

> 1. 实现简单
> 2. 元素不需要进行排序



#### 缺点

> 搜索效率低



#### 时间复杂度：O(N)



## 6.3 二分搜索

### 6.2.1 使用的表

> 二分搜索使用已排序的数组作为搜索表



### 6.2.2 代码 

#### 6.2.2.1 普通版

##### 6.2.2.1.1 递归实现

```java
public int binarySearch(Type x, int low, int high ) {
//折半搜索的递归算法
      int mid = -1;
      if ( low <= high ) {
      mid = ( low + high )/2;
      if ( elements[mid].getKey( ) < x )
         mid = binarySearch ( x, mid +1, high );
      else if ( element [mid].getKey( ) > x )	
	       mid = binarySearch ( x, low, mid -1 ); 
    }
    return mid;
}
```

##### 6.2.2.1.2 迭代实现

与递归的区别是，使用了while循环来实现

```java
public int binarySearch (Type x) {	      
//折半搜索的迭代算法 
    int high =  size-1 ,  low = 0,  mid;	      
    while ( low<=high ) {		 
        mid = ( low + high ) / 2;		 
        if ( elements[mid].getKey ( ) < x ) 
           low = mid+1 ;			 
        else if ( Element[mid].getKey ( ) > x ) 
           high = mid - 1 ;
        else return mid;
    }	  
    return -1;
}

```



#### 6.2.2.2 返回上下界版

> 在没有搜索到指定的元素时，返回最靠近这个元素的两个元素

```java
    int high = size-1,  low = 0,  mid;	      
    while (low <=high) {		 
        mid = (low + high) / 2;		 
        if ( elements[mid].getKey ( ) < x ) 
               low = mid+1;			 
        else if ( elements[mid].getKey ( ) > x ) 
                high=mid-1;
        else { 
            ret[0]=ret[1] = ret[2] = mid;
        }
    }	  
    ret[0]=-1; ret[1]=high; ret[2]=low;
    return ret;
}

```



### 6.2.3 复杂度分析

###### worst-case

> 1. 成功：[Log<sub>2</sub>N]+1
> 2. 失败：[Log<sub>2</sub>N]+1



###### best-case

> 1:一次成功



###### average

> 元素在每个位置上的几率也视为是均等的
>
> ASL = P1*C1+P2\*C2+...+Pn\*Cn  = $\displaystyle \sum^{h}_{j \to 1}{\frac{1}{n}}j·2^{j-1}$
>
> $\approx log_2(n+1)-1$



[<img src="https://s1.ax1x.com/2020/08/10/aqfGnK.md.jpg" alt="aqfGnK.md.jpg" style="zoom:67%;" />](https://imgchr.com/i/aqfGnK)



## 6.4 二叉搜索树(Binary Searching Tree)

### :fire:6.4.1 概念

###### 二叉搜索树的介绍

> - BST是一种特殊的、有特定顺序的二叉树(可以认为是规则更加严格的heap)
> - BST通过维护这种顺序，来实现快色的查询、插入、删除元素的功能
> - BST被用于解决动态搜索问题



###### 二叉搜索树的定义

> 二叉搜索树是：
>
> 1. 一棵空的树
> 2. 拥有节点，且满足一个节点大于其左子树中所有节点，并小于其右子树中所有节点的条件



### 6.4.2 构造树和节点的代码

#### 6.4.2.1 节点

```java
class BstNode<Type>{
  Type data;
  BstNode<Type> leftChild, rightChild;
  public BstNode( ) {
     leftChild = rightChild = null;
  }
  public BstNode(Type d){
    data = d;
    leftChild = rightChild = null;
  }
  public BstNode(Type d, BstNode<Type> l, BstNode<Type> r){
    data = d;
    leftChild = l;
    rightChild = r;
  }
}
```



#### 6.4.2.2 树

```java
public class BST<Type>{ 
//可继承于 BinaryTree<Type> 
  private BstNode<Type> root;      //二叉搜索树的根
  public BST()
  {root = null;}
  public void makeEmpty()
  {root=null;}
  public boolean isEmpty()
  {return root==null;}    
  ...
}
```



### 6.4.3 二叉搜索树的常见操作

#### 6.4.3.1 find

###### 查询操作的思路：

> 查询最小值：最左下的节点
>
> 查询最大值：最右下的节点
>
> 普通查询：与根节点比较，比根节点小则往左子树走，否则往右子树走



```java
BstNode <Type> find(Type x){
//二叉搜索树的迭代的搜索算法
    BstNode<Type> t = root;   
    while ( t != null) {
      int result = x.compareTo(t.data);
      if(result<0) t = t.leftChild;
      else if(result>0) t=t.rightChild;
      else return t;
    }
    return null; //搜索失败
}
```

（其他的搜索方法类似，此处略）

#### 6.4.3.2 insert

> 与插入处的节点比：小的话往左子树走，大的话往右子树走



```java
private BstNode<Type> insert (Type x, BstNode<Type> t) {
//递归的二叉搜索树插入算法
   if ( t == null)           //空二叉树
       t = new BstNode<Type>(x);     //创建含 x 结点
   int result = x.compareTo(t.data);    
   if (result<0)          //在左子树插入
      t.leftChild = insert( x, t.leftChild);
   else if (result>0)         //在右子树插入
      t.rightChild = insert(x, t.rightChild);
   else return; //Duplicate; do nothing
   return t;
}
public void insert(Type x)
{ root = insert(x, root); }
```



#### 6.4.3.3 remove

> 考虑三种不同的情况：
>
> 1. 移除的节点是叶子节点
>
>    直接删除
>
> 2. 移除的节点有一个子节点
>
>    将待移除节点父节点对它的引用移动到子节点上
>
> 3. **移除的节点有两个子节点**
>
>    将待删除的节点替换为其右子树上的最小节点(右子树上的对应节点也要做删除处理)



```java
private BstNode<Type> remove (Type x, BstNode<Type> t){
    if ( t == null ) return t; //Item not found, do nothing
    int result = x.compareTo(t.data);  
    if ( result<0 ) t.leftChild = remove ( x, t.leftChild ); 
    else if ( result>0 ) t.rightChild = remove ( x, t.rightChild );
    else   //namely x equals to t.data and t is the removed node
    if ( t.leftChild != null &&  t.rightChild != null ){ //t has 2 children
        t.data = findMin(t.rightChild).data;
        t.rightChild = remove(t.data, t.rightChild);
    }
    else //t only has 1 child
        t = (t.leftChild!=null) ? t.leftChild : t.rightChild;
    return t;
}
```



### 6.4.4  复杂度分析

###### worst-case

O(N)

> 按照升序/降序的顺序构建二叉搜索树，会导致二叉搜索树失去平衡，退化为链表，因此worst-case为O(N)



TIPS:如果二叉搜索树没有失去平衡，则worst-case可以保持O(log~2~N)的表现



###### best-case

O(1)

> 查询节点为根节点时





### 6.4.5  二叉搜索树的退化

> 如果构建BST时，进行插入的序列都是有序的(升序/降序)，则必然会导致BST退化为链表，从而大幅降低搜索效率到O(N)



解决方式：判断BST是否失去平衡，并主动进行BST的平衡操作

(AVL树即为其中一种解决方式)



## :fire: 6.5 AVL树

### 6.5.0 二叉搜索树的平衡

> 如果构建二叉搜索树时不加以限制，则BST可能会部分/完全退化为链表，从而大幅降低搜索效率。因此，需要对在构建BST时进行平衡



###### 失去平衡的BST

[![aLqRHA.md.jpg](https://s1.ax1x.com/2020/08/11/aLqRHA.md.jpg)](https://imgchr.com/i/aLqRHA)





### 6.5.1 四种不同的平衡策略

> 1. 不平衡
>
>    顾名思义，不做任何处理
>
> 2. 严格的平衡
>
>    确保BST一定是完全二叉树，每次insert以后都执行这个检测
>
>    **==TIPS:这样做的开销很大==**
>
> 3. 较好的平衡
>
>    左右子树高度的插值的绝对值小于等于1(能够接受一定程度的不平衡)
>
>    
>
>    常见的算法：
>
>    - Adeson-Velskii and Landis trees(==AVL trees==)
>    - B-trees
>
> 4. 自动调节维持平衡
>
>    常见的算法：
>
>    - Splay trees



### 6.5.2 N(h)的概念

#### 6.5.2.1 概念

> 高度为h的AVL树至少需要有的节点个数



#### 6.5.2.2 取值

##### 6.5.2.2.1 基本情况

N(0)\==1,N(1)==2

##### 6.5.2.2.2 推导情况

N(h)==N(h-1)+N(h-2)+1

N(h) > $\theta^h$( $\theta \approx$1.62)

n >= N(h)

h <= 1.44log~2~n 

### :fire: 6.5.3 插入后的平衡

> 向一棵处于平衡状态的AVL树插入新的节点并打破平衡的情况分为以下四种



#### 6.5.3.1 LL

##### 解释

> 在根节点的左子树上插入左子节点



##### 示意图

[![aOpejP.md.jpg](https://s1.ax1x.com/2020/08/11/aOpejP.md.jpg)](https://imgchr.com/i/aOpejP)

##### 平衡方式

> 进行“右旋转”(Right Rotation)



1. 从插入节点的位置开始，寻找第一个失去平衡的节点
2. 以该节点为轴，进行顺时针旋转



##### 代码

```java
private AVLNode rotateRight(AVLNode a) {
	
    /*a是第一个失去平衡的节点*/
    
    /*更改a的子节点对根节点的引用*/
    AVLNode b = a.left;
    b.parent = a.parent;

    /*更新a节点的左子节点(原先的左子节点将成为a节点的父节点)*/
    a.left = b.right;

    /*如果a节点的新的左子节点不为空，则更改其对父节点的引用为a*/
    if (a.left != null)
        a.left.parent = a;

    /*将a节点原先的子节点的对子节点的引用更新*/
    b.right = a;
    a.parent = b;

    /*如果当前新的节点的父节点不为空(新的节点不是被放在根节点的位置上)，就更新父节点对子节点的引用为b*/
    if (b.parent != null) {
        if (b.parent.right == a) {
            b.parent.right = b;
        } else {
            b.parent.left = b;
        }
    }

    /*重新设置节点的平衡度*/
    setBalance(a, b);

    return b;
}
```



#### 6.5.3.2 LR

##### 解释

> 在根节点的左子树上插入右子节点



##### 示意图

[![aOFuFO.md.jpg](https://s1.ax1x.com/2020/08/11/aOFuFO.md.jpg)](https://imgchr.com/i/aOFuFO)

##### 平衡方式

> 进行两次旋转，第一次做左旋转，第二次做右旋转



1. 从插入节点的位置开始，寻找第一个失去平衡的节点a
2. 获取这个节点失去平衡的子树的根节点b
3. 获取这个子树的根节点的失去平衡的子树的根节点c
4. 以b为轴，对b,c节点做左旋转
5. 以a为轴，对a,c节点做右旋转





##### 代码

```java
/*此处直接复用之前单次旋转的代码即可*/
private AVLNode rotateLeftThenRight(AVLNode n) {
    n.left = rotateLeft(n.left);
    return rotateRight(n);
}
```



#### 6.5.3.3 RR

##### 解释

> 在根节点的右子树上插入右子节点
>
> LL的镜像





#### 6.5.3.4 RL

##### 解释

> 在根节点的右子树上插入左子节点
>
> LR的镜像



==总结：插入后的平衡实际上就是重构父子节点的关系==



### 6.5.4 删除后的平衡

#### 6.5.4.1 BST的删除

> BST的删除与普通的二叉树的删除类似



删除的步骤

1. 搜索指定节点
2. 判断这个节点是否有子节点
   - 0个：直接删除，将此节点父节点对它的引用置空
   - 1个：删除这个节点，将父节点对它的引用替换为对它子节点的引用
   - 2个：删除这个节点，将父节点对它的引用替换为对其左子树的最右下节点的引用，并删除对应的节点

#### 6.5.4.2 要求

> 与插入时只考虑一个节点不同，删除时可能会导致多个祖先节点失衡，因此需要一路访问到root，确保被删除节点的祖先节点均能够维持平衡



## 6.6 B树

### 6.6.1 使用B树的背景和动机

> 相对于访问主存，访问磁盘的效率非常低(一般指机械硬盘)，访问一次磁盘的时间$\approx$执行200000条指令的时间。因此，编写程序时希望能够尽量介绍对磁盘的访问需求，故考虑降低树的高度。



### 6.6.2 B-Tree的定义

> m叉B-tree是一种m叉的树，每个节点至多有m个子节点。此外，B-tree还需要满足特定的要求。



### :fire:6.6.3 B-tree的要求

1. 非叶子节点的节点的key比其叶子节点的个数少一个(n个key就可以分出n+1个区间)

2. 所有的叶子节点都处于同一层
3. 除了根节点外的其他所有节点至少有[m/2]-1个key、至多，m-1个key
4. 根节点要么是一个叶子节点，要么有2~m个子节点
5. m必须是奇数



### :fire:6.6.4 B-Tree的构造过程

###### 条件

阶数为m，序列为list



###### 过程

1. 把前m-1个元素作为根节点
2. 添加一个元素后，选取中值作为根节点，剩下的平均分为两个子节点
3. 添加新元素到对应的位置上，并判断是否超过m-1的限制
   - 否：继续
   - 是：选取中值作为......（同2）
4. 重复3，直到list中的所有元素都插入b-tree中



### 6.6.5 B-Tree中key的删除

> 在B-tree中删除key一共可能有三种情况



##### 6.6.5.1 删除叶子节点中的key

###### 该叶子节点中的key足够多

> 直接删除此key即可



###### 该叶子节点中的key不够多，但兄弟节点中的key足够多

> 将兄弟节点中最后/前的key值提到根节点中，然后将根节点中原来的最前/最后的key下放到目标节点处，然后删除



###### 该叶子节点中的key不够多，兄弟节点中的key也不够多

> 将父节点中对应的key和下面两个节点和成一个节点，再删除



##### 6.6.5.2  删除非叶子节点中的key

删除此非叶子节点后，从叶子节点中获取一个节点补位，从而将问题转化为删除叶子节点



### 6.6.6 B-Tree能容纳的最多节点个数

根节点：m-1

level1：m(m-1)  (根节点最多有m个子节点，每个子节点中最多有m-1个key)

levelh：m^h^(m-1)



> 可以发现，向下时，节点的数量以等比数列形式递增



===> Total: m^h+1^-1





# Chap7.图

## 7.1 图的定义与术语

### 7.1.1 图的定义

### 7.1.2 图的术语



## 7.2 图的表示

### 7.2.1 图的接口

### 7.2.2 图的矩阵表示

### :fire:7.2.3 图的邻接表表示

#### 7.2.3.1 邻接表的概念

#### 7.2.3.2 工具类

#### 7.2.3.3 邻接表的常用操作



## 7.3 图的遍历

### 7.3.1 DFS

#### 7.3.1.1 定义

#### 7.3.1.2 思路

#### 7.3.1.3 代码

### 7.3.2 BFS 

#### 7.3.2.1 定义

#### 7.3.2.2 思路

#### 7.3.2.3 代码



## :fire:7.4 最小生成树

### 7.4.1  最小生成树的概念

### 7.4.2 Kruskal's Algorithm

### 7.4.3 Prim‘s Algorithm



## 7.5 最短路径算法

### :fire: 7.5.1 Dijkstra's Algorithm

### 7.5.2 Floyd's Algorithm





## 7.6 网络流问题(NetWork Flow Problems)

### 7.6.1 网络流问题的概念

#### 7.6.1.1 AOV网络

#### 7.6.1.2 AOE网络



### 7.6.2 使用邻接表存储AOE网络



### 7.6.3 拓扑排序

#### 7.6.3.1 目的

#### 7.6.3.2 思路

#### 7.6.3.3 代码



### 7.6.4 AOE网络

#### 7.6.4.1 关键路径

#### 7.6.4.2 活动的最早/晚开始时间的计算





# Chap8.排序

## 8.1 排序问题

### 8.1.1 简介

### 8.1.2 排序算法的稳定与不稳定

### 8.1.3 常见的排序算法



## 8.2 插入排序

### 8.2.1 插入排序的概念 



### 8.2.2 普通的插入排序

#### 8.2.2.1 概念

#### 8.2.2.2 代码



### :fire:8.2.3 Shell Sort

#### 8.2.3.1 概念

#### 8.2.3.2 代码

#### 8.2.3.3 时间复杂度分析

## 8.3 移位排序

### 8.3.1 冒泡排序

#### 8.3.1.1 概念

#### 8.3.1.2 代码

#### 8.3.1.3 时间复杂度分析

### :fire:8.3.2 快速排序

#### 8.3.2.1 概念

#### :fire:8.3.2.2 思路

#### 8.3.2.3 代码

#### 8.3.2.4 时间复杂度分析





## 8.4 选择排序

### 8.4.1 简单选择排序

#### 8.4.1.1 概念

#### 8.4.1.2 代码



### 8.4.2 堆排序

#### 8.4.1.1 概念

#### 8.4.1.2 时间复杂度分析





## :fire:8.5 归并排序

### 8.5.1 使用分治法实现排序

### 8.5.2 概念

### 8.5.3 思路

### 8.5.4 代码

### 8.5.5 时间复杂度分析



## 8.6 基数排序

### 8.6.1 概念

### 8.6.2 思路

### 8.6.3 时间复杂度分析



# Chap9.哈希

## 9.1 哈希问题

### 9.1.1 背景介绍

### 9.1.2 字典

### 9.1.3 空间浪费问题与解决



## 9.2 哈希函数

### 9.2.1 作用

### 9.2.2 对String的处理

#### 9.2.2.1 法一：ASCII码加和

#### 9.2.2.2 法二：ASCII码*27^i^

#### 9.2.2.3 法三：使用ASCII码进行更复杂的计算



## 9.3 冲突处理

### 9.3.1 冲突的概念

### 9.3.2 解决方法

#### 9.3.2.1 链地址法

#### 9.3.2.2 开地址法

##### 9.3.2.2.1 线性探查法

##### 9.3.2.2.2 平方探查法

##### 9.3.2.2.3 二次哈希



## 9.4 实现

### 9.4.1 节点

### 9.4.2 表

### 9.4.3 装填因子分析