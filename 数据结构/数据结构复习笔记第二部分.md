# Chap6.搜索

## 6.1 搜索问题

### 6.1.1 搜索表

> 搜索表是存储待搜索元素的集合



搜索表可以分为静态搜索表和动态搜索表

###### 静态搜索表

> 静态搜索表中的元素是不改变的
>
> e.g. 数组，集合，......



###### 动态搜索表

> 动态搜索表中的元素不仅可以被搜索，还可以进行更改
>
> e.g. 堆，二叉搜索树，......



### 6.1.2 概念

> 给定搜索关键字(Key)，在搜索表中寻找对应的元素，并返回元素或下标
>
> 如果结果重复，则返回任意一个均可



### 6.1.3  评价搜索效率的数字

常用的搜索效率评价数字有以下几个：

> 1. 不成功搜索比较次数(遍历所有元素)
> 2. worst-case比较次数
> 3. average比较次数





## 6.2 顺序搜索

### 6.2.1 使用的表

> 对于顺序搜索，使用数组存储未排序的元素即可



### 6.2.2 代码 

###### 节点定义

```java
static search table
class Node<Type> {
  Type key; //关键码
   others; //其他域
   public Node( const Type & value ) : key ( value ) { }
   public Type getKey ( ) const { return key; } //读关键码
   public void setKey ( Type k ) { key = k; } //修改关键码
}
```



顺序搜索较简单，其他的代码略



### 6.2.3 复杂度分析

###### 成功比较次数

> 1. best：1
>
> 2. worst：n
>
> 3. average： (nP1+(n-1)P2+...+1*Pn)/n 
>
>    因为在各个位置上出现的几率相等，所以P1=P2=...=Pn=1/n
>
>    average=(n+1)/2



###### 不成功比较次数

> n+1：原因是回到下标为0的元素处时，做了最后一次比较操作



###### 平均比较次数

> (n+1)/2/2+(n+1)/2=3*(n+1)/4



### 6.2.4 优缺点

#### 优点

> 1. 实现简单
> 2. 元素不需要进行排序



#### 缺点

> 搜索效率低



#### 时间复杂度：O(N)



## 6.3 二分搜索

### 6.2.1 使用的表

> 二分搜索使用已排序的数组作为搜索表



### 6.2.2 代码 

#### 6.2.2.1 普通版

##### 6.2.2.1.1 递归实现

```java
public int binarySearch(Type x, int low, int high ) {
//折半搜索的递归算法
      int mid = -1;
      if ( low <= high ) {
      mid = ( low + high )/2;
      if ( elements[mid].getKey( ) < x )
         mid = binarySearch ( x, mid +1, high );
      else if ( element [mid].getKey( ) > x )	
	       mid = binarySearch ( x, low, mid -1 ); 
    }
    return mid;
}
```

##### 6.2.2.1.2 迭代实现

与递归的区别是，使用了while循环来实现

```java
public int binarySearch (Type x) {	      
//折半搜索的迭代算法 
    int high =  size-1 ,  low = 0,  mid;	      
    while ( low<=high ) {		 
        mid = ( low + high ) / 2;		 
        if ( elements[mid].getKey ( ) < x ) 
           low = mid+1 ;			 
        else if ( Element[mid].getKey ( ) > x ) 
           high = mid - 1 ;
        else return mid;
    }	  
    return -1;
}

```



#### 6.2.2.2 返回上下界版

> 在没有搜索到指定的元素时，返回最靠近这个元素的两个元素

```java
    int high = size-1,  low = 0,  mid;	      
    while (low <=high) {		 
        mid = (low + high) / 2;		 
        if ( elements[mid].getKey ( ) < x ) 
               low = mid+1;			 
        else if ( elements[mid].getKey ( ) > x ) 
                high=mid-1;
        else { 
            ret[0]=ret[1] = ret[2] = mid;
        }
    }	  
    ret[0]=-1; ret[1]=high; ret[2]=low;
    return ret;
}

```



### 6.2.3 复杂度分析

###### worst-case

> 1. 成功：[Log<sub>2</sub>N]+1
> 2. 失败：[Log<sub>2</sub>N]+1



###### best-case

> 1:一次成功



###### average

> 元素在每个位置上的几率也视为是均等的
>
> ASL = P1*C1+P2\*C2+...+Pn\*Cn  = $\displaystyle \sum^{h}_{j \to 1}{\frac{1}{n}}j·2^{j-1}$
>
> $\approx log_2(n+1)-1$



[<img src="https://s1.ax1x.com/2020/08/10/aqfGnK.md.jpg" alt="aqfGnK.md.jpg" style="zoom:67%;" />](https://imgchr.com/i/aqfGnK)



## 6.4 二叉搜索树(Binary Searching Tree)

### :fire:6.4.1 概念

###### 二叉搜索树的介绍

> - BST是一种特殊的、有特定顺序的二叉树(可以认为是规则更加严格的heap)
> - BST通过维护这种顺序，来实现快色的查询、插入、删除元素的功能
> - BST被用于解决动态搜索问题



###### 二叉搜索树的定义

> 二叉搜索树是：
>
> 1. 一棵空的树
> 2. 拥有节点，且满足一个节点大于其左子树中所有节点，并小于其右子树中所有节点的条件



### 6.4.2 构造树和节点的代码

#### 6.4.2.1 节点

```java
class BstNode<Type>{
  Type data;
  BstNode<Type> leftChild, rightChild;
  public BstNode( ) {
     leftChild = rightChild = null;
  }
  public BstNode(Type d){
    data = d;
    leftChild = rightChild = null;
  }
  public BstNode(Type d, BstNode<Type> l, BstNode<Type> r){
    data = d;
    leftChild = l;
    rightChild = r;
  }
}
```



#### 6.4.2.2 树

```java
public class BST<Type>{ 
//可继承于 BinaryTree<Type> 
  private BstNode<Type> root;      //二叉搜索树的根
  public BST()
  {root = null;}
  public void makeEmpty()
  {root=null;}
  public boolean isEmpty()
  {return root==null;}    
  ...
}
```



### 6.4.3 二叉搜索树的常见操作

#### 6.4.3.1 find

###### 查询操作的思路：

> 查询最小值：最左下的节点
>
> 查询最大值：最右下的节点
>
> 普通查询：与根节点比较，比根节点小则往左子树走，否则往右子树走



#### 6.4.3.2 insert



#### 6.4.3.3 remove



### 6.4.4  复杂度分析

###### worst-case



###### best-case







### 6.4.5  二叉搜索树的退化

> 如果构建BST时，进行插入的序列都是有序的(升序/降序)，则必然会导致BST退化为链表，从而大幅降低搜索效率到O(N)



解决方式：判断BST是否失去平衡，并主动进行BST的平衡操作

(AVL树即为其中一种解决方式)



## 6.5 AVL树

### 6.5.0 二叉搜索树的平衡

### 6.5.1 四种不同的平衡策略

### 6.5.2 N(h)的概念

### :fire: 6.5.3 插入后的平衡

### 6.5.4 删除后的平衡



## 6.6 B树

### 6.6.1 使用B树的背景和动机

### 6.6.2 B-Tree的定义

### :fire:6.6.3 B-tree的要求

### :fire:6.6.4 B-Tree的构造过程

### 6.6.5 B-Tree中节点的删除

### 6.6.6 B-Tree能容纳的节点个数



# Chap7.图

## 7.1 图的定义与术语

### 7.1.1 图的定义

### 7.1.2 图的术语



## 7.2 图的表示

### 7.2.1 图的接口

### 7.2.2 图的矩阵表示

### :fire:7.2.3 图的邻接表表示

#### 7.2.3.1 邻接表的概念

#### 7.2.3.2 工具类

#### 7.2.3.3 邻接表的常用操作



## 7.3 图的遍历

### 7.3.1 DFS

#### 7.3.1.1 定义

#### 7.3.1.2 思路

#### 7.3.1.3 代码

### 7.3.2 BFS 

#### 7.3.2.1 定义

#### 7.3.2.2 思路

#### 7.3.2.3 代码



## :fire:7.4 最小生成树

### 7.4.1  最小生成树的概念

### 7.4.2 Kruskal's Algorithm

### 7.4.3 Prim‘s Algorithm



## 7.5 最短路径算法

### :fire: 7.5.1 Dijkstra's Algorithm

### 7.5.2 Floyd's Algorithm





## 7.6 网络流问题(NetWork Flow Problems)

### 7.6.1 网络流问题的概念

#### 7.6.1.1 AOV网络

#### 7.6.1.2 AOE网络



### 7.6.2 使用邻接表存储AOE网络



### 7.6.3 拓扑排序

#### 7.6.3.1 目的

#### 7.6.3.2 思路

#### 7.6.3.3 代码



### 7.6.4 AOE网络

#### 7.6.4.1 关键路径

#### 7.6.4.2 活动的最早/晚开始时间的计算





# Chap8.排序







# Chap9.哈希



