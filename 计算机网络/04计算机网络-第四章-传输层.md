[TOC]

# Chap4 传输层

## 4.0 目标

- 理解传输层服务背后的原理
  - 复用与解复用
  - 可靠数据传输
  - 流控制
  - 拥塞控制
- 了解传输层的重要协议
  - UDP
  - TCP
  - TCP拥塞控制



## 4.1 传输层提供的服务

> **核心**：提供运行在不同主机上的进程间的通信服务



### 4.1.1 简介

- 传输层协议运行在终端系统(end system)上

  - 发送方

    将应用层的message拆分成segments，并交给网路层进行传输

  - 接收方

    将segments重新组装为message，并向应用层交付

- app可以使用不同的传输层协议



### 4.1.2 传输层与网络层的对比

###### 传输层

> 进程之间的逻辑通信
>
> - 需要依靠网络层提供的服务，并在本层解决可靠数据传输的问题



###### 网络层

> 主机间的逻辑通信



### 4.1.3 进程间的通信

- 应用进程间的通信称为==端到端的通信==
- 运输层的一个重要功能是复用与分用
- 运输层之间提供==逻辑通信==，即没有一条实际的直接连接，而是通过使用网络层的服务实现
- 注意，网络核心部分的路由器并不需要运输层，它们只使用网络层及以下的层次





[<img src="https://s1.ax1x.com/2020/08/30/dqCRG6.jpg" alt="dqCRG6.jpg" style="zoom:67%;" />](https://imgchr.com/i/dqCRG6)



### 4.1.4 两种不同的运输协议(TCP和UDP)

> 运输层向高层屏蔽了下层网络核心的细节(拓扑结构、路由协议等)
>
> - 如果采用TCP连接，虽然网络层的服务是不可靠的，但对于应用层，TCP实际上提供了可靠传输的服务
> - UDP则不提供，可靠传输要由应用层实现



#### 4.1.4.1 TCP

###### 提供服务

> - 拥塞控制
> - 流控制
> - 连接建立
> - 可靠数据传输



###### TPDU

> TCP报文段



#### 4.1.4.2 UDP

###### 提供服务

> - 不可靠的数据传输



###### TPDU

> UDP报文/用户数据报(注意与IP数据报完全不同)



### 4.1.5 端口

> 为了让其他主机定位到一个主机上的进程，需要使用协议端口号来实现
>
> - 在本机上，进程通过进程表示符来标志，但显然不应该将进程表示符暴露给互联网上的其他主机



#### 4.1.5.1 软件端口与硬件端口

###### 软件端口

> 协议栈各层间抽象的协议端口



###### 硬件端口

> 不同硬件设备进行交互的接口，比如路由器上的端口、交换机上的端口等



#### 4.1.5.2 TCP的端口

- 端口使用一个16bits的端口号标识
- 端口号只在本地由意义，作用就是为了标识计算机应用层中的各个进程

Tips：UDP中也需要使用端口，与TCP的端口很相似，因此略(实际使用中会注明端口的类型)



#### 4.1.5.3 三类端口

**1. 熟知端口1~1023**

- 它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议，例如：80端口实际上总是HTTP通讯。

**2. 登记端口号1024~49151**

- 它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的。
- 使用这个范围的端口号必须在IANA进行登记，以避免重复



**3. 客户端口号/短暂端口号49152~65535**

- 留给客户进程选择暂时使用
- 不需要登记
- 使用完会被释放，供其他进程使用



### 4.1.6 TCP连接

> - TCP将连接作为最基本的抽象
> - 每条TCP连接都有两个端点
> - TCP连接的断电是==套接字(socket)==



###### socket

> 套接字由IP地址与端口号的组合构成

[![dqkCod.jpg](https://s1.ax1x.com/2020/08/30/dqkCod.jpg)](https://imgchr.com/i/dqkCod)



每个TCP连接被一对套接字所确定

> TCP: {socket1,socket2}



## 4.2 复用与解复用

### 4.2.1 基本概念介绍

###### 复用

> 从不同的socket处获取数据，并加上传输层的header



###### 解复用

> 根据header将segment交付到正确的目的socket上



### 4.2.2 解复用

#### 4.2.2.1 解复用的原理

主机收到IP数据报后：

- 每个数据报都有源IP地址和目的IP地址
- 每个数据报都携带一个传输层的segment
- 每个segment持有源端口号和目的端口号



综上，根据IP地址和端口号，主机就可以将segment送到正确的socket处



#### 4.2.2.2 无链接的解复用

> 主机收到segment后：
>
> - 检查端口号
> - 根据端口号将UDP segment传输到指定socket处



#### 4.2.2.3 面向连接的的解复用

> - TCP socket有四个信息，即源/目的IP地址与源/目的端口号
> - 接收主机会使用这四个信息来讲segment传输到指定的socket处



## :fire:4.3 无连接的传输：UDP

#### 4.3.1 UDP的基本介绍

###### UDP的特点

> - “无装饰的”，“基本的”Internet传输协议
> - 提供“尽最大努力的”服务(不保证质量)
> - 无连接的
> - 常用于流媒体的数据传输
> - 其他的用处
>   - DNS
>   - SNMP(简单网络管理协议)
> - 可靠传输靠应用层保证



###### 为什么需要UDP

> - UDP不需要建立连接
> - 简单
> - 更小的首部，降低传输成本
> - 没有拥塞控制



#### 4.3.2 面向报文的UDP

> 面向报文，指的是UDP直接把应用层加上header以后就发送，不做任何拆分与合并工作。因此，应用层必须自己选择一个合适大小的报文(message)

[![dqMNgH.jpg](https://s1.ax1x.com/2020/08/30/dqMNgH.jpg)](https://imgchr.com/i/dqMNgH)



#### 4.3.3 UDP's Header

###### 首部

> 包含端口号，长度等



###### 伪首部

> 从IP数据报首部提取后构成伪首部，用于进行校验和，来判断是否发送给本机、以及确认是否出现误传

[<img src="https://s1.ax1x.com/2020/08/30/dqQ9PO.jpg" alt="dqQ9PO.jpg" style="zoom:67%;" />](https://imgchr.com/i/dqQ9PO)



#### 4.3.4 UDP校验和

#### 4.3.4.1 校验的目的

> 在需要被传输的UDP数据报中检验错误



#### 4.3.4.2 校验的方式

> UDP使用“伪首部”校验和来进行错误的检测



#### 4.3.4.3 实际的做法

###### 发送方

- 把segment的内容当作16bits的数(注意，包括了data字段)
- 求和，按位取反(1's complement)
- 将结果存入UDP数据报的校验和字段
- 去掉伪首部，传输UDP数据报



###### 接收方

- 把segment的内容当作16bits的数(注意，包括了data字段)
- 求和，按位取反(1's complement)
- 检查值与校验和字段是否一致
  - 一致：正常接收，认为传输未出错(实际上仍有可能出错)
  - 不一致：认为传输出错，抛弃UDP数据报



## 4.4 可靠数据传输的原理

### 4.4.1 TCP的简介

#### 4.4.1.1 TCP的特点

> - TCP是面向连接的
> - TCP连接只能有两个端点
> - TCP提供可靠交付服务
> - TCP提供全双工通信
> - TCP面向字节流



[![dqGWMF.jpg](https://s1.ax1x.com/2020/08/30/dqGWMF.jpg)](https://imgchr.com/i/dqGWMF)



###### TCP的其他注意事项

> - TCP是逻辑上的虚拟连接
> - TCP不关心应用程序一次发送多长的报文到缓冲中
> - TCP根据对方给出的窗口值和网络拥塞的情况，决定TCP报文段的长度
> - TCP可能会拆分数据块，也可能会合并数据块



### 4.4.2 可靠数据传输的原理

#### 4.4.2.1 可靠数据传输的基础概念

> 传输层实现的可靠数据传输，即是通过在出现丢包/错误等情况时，通过重传等手段，确保交付给应用层的message是无误的。也就是向上层提供了可靠的数据传输服务。

[![dOtKr8.jpg](https://s1.ax1x.com/2020/08/31/dOtKr8.jpg)](https://imgchr.com/i/dOtKr8)



#### 4.4.2.2 不同版本的rdt

##### 4.4.2.2.1 rdt1.0——假设信道完全可靠

###### 思想

> 发送方直接发送，接收方直接接收，不做任何其他处理



###### 有限状态机图

注：横线上方为事件(比如调用了xx方法)，横线下方为action，表示实际的操作

[![dONZo4.jpg](https://s1.ax1x.com/2020/08/31/dONZo4.jpg)](https://imgchr.com/i/dONZo4)



##### 4.4.2.2.2 rdt2.0——信道可能会有位错误(bit errors)

###### 思想

> 通过使用ACK/NAK信号来传递packet是否正确接收



###### 有限状态机图

[<img src="https://s1.ax1x.com/2020/08/31/dONJTe.jpg" alt="dONJTe.jpg" style="zoom:67%;" />](https://imgchr.com/i/dONJTe)







##### 4.4.2.2.3 rdt2.1——解决2.0中，ACK/NAK出错的情况

###### 前提

> rdt2.0的最大问题是，ACK/NAK信息也可能出错



###### 思想

> 使用一个bit作为标识符(0,1)，每次发送后标识符切换，如果收到的packet的标识符与理论值不一样，则说明出现了错误，需要重传；如果传输错误，也要重传



###### 有限状态机图

> 发送方
>
> - 发送方收到错误信号/标识符错误的正确信号，都要重传
>
> [<img src="https://s1.ax1x.com/2020/08/31/dOdlyq.jpg" alt="dOdlyq.jpg" style="zoom:67%;" />](https://imgchr.com/i/dOdlyq)
>
> 
>
> 接收方
>
> [<img src="https://s1.ax1x.com/2020/08/31/dOdGwT.jpg" alt="dOdGwT.jpg" style="zoom:67%;" />](https://imgchr.com/i/dOdGwT)



##### 4.4.2.2.4 rdt2.2——在2.1的基础上，免除NAK的使用

###### 思想

> - 与rdt2.1的功能一致，但省略了NAK，而只使用ACK
> - 如果发送方收到了序号不正确的ACK，就视为NCK



###### 有限状态机图

[<img src="https://s1.ax1x.com/2020/08/31/dOrtzQ.md.jpg" alt="dOrtzQ.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dOrtzQ)



##### 4.4.2.2.5 rdt3.0——信道不仅会有位错误，还有可能丢包(==实际的情况==)

###### 思想

> - 在rdt2.2的基础上，加入对时间的判断，如果超时，也要重传
> - 其他部分和rdt2.2一致



###### 有限状态机图

[<img src="https://s1.ax1x.com/2020/08/31/dOss0I.jpg" alt="dOss0I.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dOss0I)



###### :zap:rdt3.0的问题

> - rdt3.0是有效的，但是效率极低

”由于rdt3.0是一种停止并等待的协议，所以每发送一个packet，就要等待至少一个RTT，才能发送下一个packet“



e.g.对于传输速率为1Gbps的链路(发送到信道上的速率)，如果传播延迟为15ms，对于一个1kb的packet，则信道的利用率为：

(L/R)/(RTT+L/R) ≈ 0.00027(小于千分之一)



### 4.4.3 流水线与可靠通信

> 为了解决rdt3.0的做法效率过低的问题，采用流水线的方式，不要求一定一个packet传输确认无误后再传下一个
>
> 为了试下流水线传输的可靠，需要使用以下两种类型的协议之一：
>
> - go-back-N
> - selective repeat



#### 4.4.3.1 Go-Back-N

- 窗口大小设为N，发送方最多能接受有N个packet没有收到确认
- 采用累计确认的方式，之确认按序到达的最后一个packet
  - e.g. 1 2 4 5 ----> 确认1，确认2，确认2，确认2
- 在base==nextseqnum后，启动计时器，nextseqnum++

[![dO7i1s.jpg](https://s1.ax1x.com/2020/08/31/dO7i1s.jpg)](https://imgchr.com/i/dO7i1s)

###### 发送方

[<img src="https://s1.ax1x.com/2020/08/31/dO7GB6.jpg" alt="dO7GB6.jpg" style="zoom:67%;" />](https://imgchr.com/i/dO7GB6)



###### 接受方

[![dO7JHK.jpg](https://s1.ax1x.com/2020/08/31/dO7JHK.jpg)](https://imgchr.com/i/dO7JHK)



#### 4.4.3.2 Selective Repeat

- 接受方对每一个packet都单独发送ACK
- sender只重传没有返回ACK的packet(超时后重传)

[![dOjnqs.jpg](https://s1.ax1x.com/2020/08/31/dOjnqs.jpg)](https://imgchr.com/i/dOjnqs)

###### 选择重传的问题

- 对于第二种情况，虽然发送认为是重传，但接收方却认为是后续的packet

[![dOjXoq.jpg](https://s1.ax1x.com/2020/08/31/dOjXoq.jpg)](https://imgchr.com/i/dOjXoq)





## 4.5 面向连接的传输：TCP

- TCP是点对点地传输协议
- TCP是可靠的，有序的字节流传输
- TCP的传输是流水线的
- 全双工
- 面向连接，有流控制

[<img src="https://s1.ax1x.com/2020/08/31/dX9ddH.md.jpg" alt="dX9ddH.md.jpg" style="zoom:50%;" />](https://imgchr.com/i/dX9ddH)



###### 发送缓存的作用

> 1. 存储需要使用TCP连接发送的数据
> 2. 已经用TCP连接发送的，但是尚未收到确认的数据



###### 接受缓存的作用

> 1. 正常按顺序到达的，但尚未呗应用程序读取的数据
> 2. 不按顺序到达的、需要暂时存储的数据(结合选择重传理解)



### 4.5.1 TCP报文的格式

#### 4.5.1.1 报文格式

[![dXCU10.md.jpg](https://s1.ax1x.com/2020/08/31/dXCU10.md.jpg)](https://imgchr.com/i/dXCU10)



1. 源端口/目的端口

   各占两字节

2. 序号(==自己的==)

   TCP传输的字节流中中每个字节都要编号，序号位最大值为2^32^-1，而TCP报文中的序号字段为数据部分的字节流的首个字节的编号

3. 确认号(==对方的==)

   希望收到的下一个TCP报文中数据部分首字节的序号

4. 数据偏移

   指出TCP报文中header部分的长度，即从源端口开始，到填充部分结束

5. 保留

   目前尚未用到，6bits，全置0

6. 控制位(URG-FIN)

   - URG：紧急字段，指示本报文要尽快传送，不排队
   - ACK：仅当ACK==1时，确认号部分才有效
   - PSH：两个进程进行交互式的通信时使用，表示需要对方尽快响应，不要等到缓冲满了再向上交付
   - RST：表示需要释放并重新建立连接
   - SYN：连接建立时的同步序号
     - ACK = 0 ,  SYN = 1：请求建立连接
     - ACK = 1, SYN = 1：同意建立连接
   - FIN：用于释放连接，释放时FIN=1

7. 窗口

   本发送方的接受窗口，让对方确定发送窗口大小的依据

8. 检验和

   略，回忆之前UDP检验和部分的介绍，此处类似(**4.3.4**)

9. 紧急指针

   指出本TCP报文中，紧急数据的字节数，一个TCP报文的数据中可以同时有紧急数据和普通数据

10. 选项

    可供选择的选项：

    - MSS：(数据部分)最大报文长度
    - 窗口扩大选项
    - 时间戳
    - ......

11. 填充

    选项部分不是4字节的整数倍时，进行填充



#### 4.5.1.2 TCP到期时间的设置

> 为了实现过期后自动重传，需要设置一个到期时间，到期时间应该与RTT，即传输时延有关。然而，传输时延一直处于变化，因此需要动态地确定到期时间(timeout)
>



:fire:核心公式： **timeout =  RTT~s~ + 4 * DevRTT**

1. RTTs:**加权平均往返时间**

   > 计算方式：新的RTT~s~ = (1-$\alpha$)*旧的RTT~s~ + $\alpha$\*新的RTT样本值

2. DevRTT：**RTT偏差的加权平均值**，反应RTT的取值震荡情况

   > 计算方式：
   >
   > - 第一次：DecRTT = 1/2 RTT样本值
   > - 后续：DevRTT = (1- $\beta$ )*旧的RTT~d~ + $\beta$\*|RTT~s~ - 新的RTT样本|



###### Karn算法

> 如果TCP报文重传了，RTT就不进行采样，这样超时重 传时间的计算更准确



###### 修正的Karn算法

> - 如果发生了重传，timeout * 2
> - 如果没有重传，则按照公式计算timeout



### 4.5.2 可靠数据传输

> - TCP使用下层的不可靠传输服务实现可靠传输
>   - 面向字节流
>   - 累积确认(如果是选择确认，则需要单独设置)
>   - 单一的计时器
> - 引发重传的原因可能是：
>   -  过期
>   - 重复ACK



###### (基于累积确认的)TCP ACK策略

- 情况1：packet有序到达，之前所有收到的packet均已ACK
  - 延迟500ms，等待新的packet，如果没有，500ms以后进行ACK
- 情况2：packet有序到达，之前的packet处于pending状态(情况一)
  - 立即ACK，对两者都进行ACK
- 情况3：packet无序到达，造成gap
  - 立刻发送重复ACK
- 情况4：packet到达后填上了gap
  - 立刻发送ACK



###### 快重传策略

> 背景：超时所需的时间往往较长
>
> 思路：通过重复ACK，尽快得出需要重传的结论
>
> 做法：当收到同一个Packet的三个重复ACK时(第一个正确的ACK不算)，重传之后的所有的packet

[<img src="https://s1.ax1x.com/2020/09/01/djxzqg.jpg" alt="djxzqg.jpg" style="zoom:67%;" />](https://imgchr.com/i/djxzqg)



### 4.5.3 流控制

#### 4.5.3.1 背景

> TCP的连接两方都有接收缓冲，但由于如果不加限制，发送速率可能持续地高于app的读取速率，因此，需要进行流控制，来平衡发送速率与app的处理速率



#### 4.5.3.2 思路

> 在建立连接和每次ACK时，向发送方告知自己的实时接收窗口，即“还能接收多少”



#### 4.5.3.3 举例

[<img src="https://s1.ax1x.com/2020/09/01/dvP1K0.md.jpg" alt="dvP1K0.md.jpg" style="zoom:67%;" />](https://imgchr.com/i/dvP1K0)



#### 4.5.3.4 持续计时器与流量控制

> - TCP为每个连接设有一个持续计时器
> - 每次收到==零窗口==通知时，就启动计时器
> - 如果到期，就发送一个探测segment，根据返回的ACK确定是否能够发送数据
>   - 窗口仍是0：重置计时器
>   - 窗口非0：开始传输



### 4.5.4 连接控制

#### 4.5.4.1 TCP连接的三个阶段

- 连接建立
- 数据传输
- 连接释放



###### 连接建立时需要解决的问题

> - 双方互相确认对方的存在
> - 允许双方协商一些参数，比如窗口大小、MSS等
> - 能够对运输实体资源，比如缓存大小，连接表中的项目等，进行分配



#### 4.5.4.2 连接建立的过程

1. 客服端请求建立
2. 服务端确认
3. 客户端确认



[<img src="https://s1.ax1x.com/2020/09/01/dvz7DO.md.jpg" alt="dvz7DO.md.jpg" style="zoom:67%;" />](https://imgchr.com/i/dvz7DO)



#### 4.5.4.3 连接释放的过程

1. 主机A==传输完自己的数据后==提议释放连接
2. 主机B接到提议后，回复ACK，宣布A-->B这个方向的连接关闭，但B仍可以继续传输
3. 传输完成后，B向A发送提议释放连接
4. A确认，双向的连接最终都关闭

[![dxCqyt.md.jpg](https://s1.ax1x.com/2020/09/01/dxCqyt.md.jpg)](https://imgchr.com/i/dxCqyt)



A需要在最后一次ACK后等待2MSL时间的原因：

- 确保ACK已经到达B
- 确保本次连接中所有的segment都在网络中消失



## 4.6 拥塞控制的原理

### 4.6.1 拥塞的简介

> - “过多的发送者发送了太多的packet到网络中，以至于网络层无法迅速处理完成”
> - 对资源需求的综合 > 实际可用的资源



==与流控制的区别：==

流控制是为了避免接收方的接收缓冲溢出，而不是考虑网络的拥塞情况



表现

- 丢包
- 时延很长



### 4.6.2 产生拥塞的情况

#### 4.6.2.1 情况1(理想情况)

###### 背景

> - 两个发送者，两个接收者
> - 路由器的buffer无限(实际上不可能)
> - 输出的链路容量:R
> - 没有重传



[<img src="https://s1.ax1x.com/2020/09/01/dvEUjs.jpg" alt="dvEUjs.jpg" style="zoom:67%;" />](https://imgchr.com/i/dvEUjs)

[<img src="https://s1.ax1x.com/2020/09/01/dvE3Af.md.jpg" alt="dvE3Af.md.jpg" style="zoom:67%;" />](https://imgchr.com/i/dvE3Af)



#### 4.6.2.2 情况2(部分实际情况)

###### 背景

> - 除了路由器的缓冲改为有限，其他情况与情况1一致
> - 因为有限的缓冲，无法保存所有packet，因此可能需要重传



[<img src="https://s1.ax1x.com/2020/09/01/dvZZyd.md.jpg" alt="dvZZyd.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dvZZyd)



由于会有重复的packet，因此及时继续增大$\lambda_{in}'$，也无法跑满R/2



###### 带来的损失

1.需要更多的重传来正确传输数据

2.由于时延较高，很可能会造成不必要的重传



#### 4.6.2.3 情况3(实际情况)

> - 网络结构复杂
> - 网络中的主机数量较多



[<img src="https://s1.ax1x.com/2020/09/01/dvZgmR.md.jpg" alt="dvZgmR.md.jpg" style="zoom: 67%;" />](https://imgchr.com/i/dvZgmR)

[<img src="https://s1.ax1x.com/2020/09/01/dvmArd.jpg" alt="dvmArd.jpg" style="zoom:67%;" />](https://imgchr.com/i/dvmArd)





###### 带来的损失

3.当packet被丢弃时，之前传输此packet的资源也就白费了



## 4.7 TCP拥塞控制

### 4.7.1 拥塞控制与流量控制

###### 拥塞控制

> - 全局性的过程
> - 涉及到所有的主机和路由器，以及降低网络传输性能的其他因素



###### 流量控制

> - 给定的发送端和接收端之间点对点通信量的控制
> - 确保接收端能够来得及接收



### 4.7.2 拥塞控制的两种思路

###### 开环控制

> 设计网络时力求将有关拥塞的因素考虑周到，尽量避免拥塞状况的出现



###### 闭环控制

> 基于反馈环路的概念
>
> - 监测网络系统以便检测到拥塞在何时、何处发生
> - 将拥塞发生的信息传送到可采取行动的地方
> - 调整网络系统的运行以解决出现的问题



### 4.7.3 实际的几种拥塞控制方法

#### 4.7.3.1 慢开始和拥塞避免

###### 拥塞窗口

> - 拥塞窗口cwnd由发送方维持，取决于网络的拥塞情况，并动态变化
>
> - 如果网络没有出现拥塞，则拥塞窗口逐渐增大；如果出现拥塞，则减小拥塞窗口
>
> - 发送方的发送窗口要同时考虑到拥塞窗口的取值和接收窗口的取值
>
>   ==取这两个窗口中较小的那一个==



###### 三个重要概念

> 1.慢开始
>
> 首先设置拥塞窗口为1，之后每收到一个ACK，就增大1
>
> 注意：实际上，这样做的效果是指数增大
>
> - 传输轮次(transmission round)的概念
>   - 其实是RTT的一种变种
>   - 指的是，把当前拥塞窗口大小的segment全部发送，并收到全部ACK所耗费的时间
> - 慢开始门限(ssthresh)的概念
>   - 确定慢开始算法和拥塞避免算法转换时机的值
>   - cwnd <  ssthresh 慢开始
>   - cwnd > ssthresh 拥塞避免
>   - cwnd == ssthresh 均可
>
> 
>
> 2.拥塞避免(“加法增大”)
>
> 进入拥塞避免阶段时，每经过一个传输轮次，cwnd只+1
>
> 
>
> 3.乘法减小
>
> 如果出现了拥塞，则立刻减小拥塞窗口：
>
> - 把ssthresh设为出现拥塞时cwnd的1/2
> - cwnd重新设为1



#### 4.7.3.2 快重传和快恢复

###### 快重传

> 4.5.2 可靠数据传输中已介绍过，即三次重复ACK后立即重传



###### 快恢复

> - 当发送方收到三个连续的ACK时，执行乘法减小算法，慢开始门限ssthresh设为当前cwnd设为1/2
> - cwnd从ssthresh开始，而不是从1开始，并执行拥塞避免算法
> - 这样的方式能够尽可能的提高传输效率



#### 4.7.3.3 随机早期检测(RED)

[![dvNdKI.jpg](https://s1.ax1x.com/2020/09/01/dvNdKI.jpg)](https://imgchr.com/i/dvNdKI)

[![dvNcGQ.md.jpg](https://s1.ax1x.com/2020/09/01/dvNcGQ.md.jpg)](https://imgchr.com/i/dvNcGQ)

注意：在L~av~处于TH~min~和TH~max~之间时，p线性增长，直到值为1

